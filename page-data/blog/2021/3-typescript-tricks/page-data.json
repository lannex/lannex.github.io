{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/2021/3-typescript-tricks/",
    "result": {"data":{"site":{"siteMetadata":{"title":"lannex"}},"markdownRemark":{"id":"8d21f482-68dc-5797-8107-e40aef98fdfd","excerpt":"첫 번째: Readonly<T…","html":"<h2 id=\"첫-번째-readonlyt\" style=\"position:relative;\"><a href=\"#%EC%B2%AB-%EB%B2%88%EC%A7%B8-readonlyt\" aria-label=\"첫 번째 readonlyt permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>첫 번째: Readonly&#x3C;T></h2>\n<p>작은 예부터 시작하겠습니다: 숫자 배열을 받아서 모든 요소가 정렬된 배열을 반환하는 간단한 함수가 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">sortNumbers</span><span class=\"token punctuation\">(</span>array<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 아래 코드를 보고 모든 것이 괜찮은지 확인하세요.\n그리고 콘솔 결과가 어떨지 생각해보세요.\n시간을 갖고 실제로 생각해보는 것을 추천합니다!</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token keyword\">const</span> sortedNumbers <span class=\"token operator\">=</span> <span class=\"token function\">sortNumbers</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span>\n\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>sortedNumbers<span class=\"token punctuation\">)</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span></code></pre></div>\n<p>첫 번째 콘솔 결과는 <code class=\"language-text\">[3, 5, 7]</code>로 꽤 간단합니다.\n하지만 두 번째 결과도 동일합니다!\n그래서 여러분은 이렇게 질문할 수 있습니다: 왜 그런가요? 배열을 <code class=\"language-text\">const</code>로 정의했는데 어떻게 바뀔 수 있죠?</p>\n<p>배열과 객체는 Javascript에서 매우 특별합니다.\n그것들을 함수에 전달하면 배열 또는 객체에 대한 참조가 이루어지므로, in-place인 <code class=\"language-text\">Array.sort</code>와 같은 특정 함수를 호출하면 기존 배열이 변경됩니다.</p>\n<p>이 상황을 구조할 Readonly 🚀</p>\n<p>코드를 약간 바꿔 보겠습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">sortNumbers</span><span class=\"token punctuation\">(</span>array<span class=\"token operator\">:</span> Readonly<span class=\"token operator\">&lt;</span><span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">>></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> array<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드는 컴파일되지 않습니다.\nTypeScript는 우리가 실제로 원하는 <code class=\"language-text\">Property ‘sort’ does not exist on type ‘readonly number[]’</code> <small>‘readonly number[]’ 타입에 ‘sort’ 속성이 없습니다.</small> 에러를 제공합니다.\n부작용 <small>side effects</small>을 일으키는 매개변수를 변경할 수 없습니다! <strong>멋집니다</strong>.\n하지만 이것이 배열을 정렬하는 함수를 가질 수 없다는 것을 의미할까요?\n물론 우린 할 수 있습니다.\n배열 자체를 정렬하는 대신 배열 복사본만 정렬하면 됩니다.\nJS에서 배열을 복사하는 방법은 전개 (<code class=\"language-text\">[...array]</code>) 처럼 <code class=\"language-text\">array.concat()</code>, <code class=\"language-text\">Array.from(array)</code> 또는 <code class=\"language-text\">array.slice()</code>를 사용 등 다양합니다.\n그럼 스프레드 연산자를 사용하여 다음과 같이 함수를 완성하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">sortNumbers</span><span class=\"token punctuation\">(</span>array<span class=\"token operator\">:</span> Readonly<span class=\"token operator\">&lt;</span><span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">>></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>array<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">-</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>끝났습니다! TypeScript에 의해 강제되는 클린 코드입니다.\nBTW: 이것은 객체에서도 작동합니다!</p>\n<p><small>JS의 가변성에 대해 자세히 알아보려면 이 <a href=\"https://www.cstrnt.dev/blog/immutability\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">글</a>을 확인하세요.</small></p>\n<h2 id=\"두-번째-any-vs-unknown\" style=\"position:relative;\"><a href=\"#%EB%91%90-%EB%B2%88%EC%A7%B8-any-vs-unknown\" aria-label=\"두 번째 any vs unknown permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두 번째: Any vs Unknown</h2>\n<p>TS와 함께 eslint를 사용할 때 <code class=\"language-text\">unexpected any</code>라는 메시지를 본 적이 있을 겁니다.\n적어도 저는 <code class=\"language-text\">any</code>가 나쁜 이유가 궁금했습니다.\n그렇지 않으면 변수가 가능한 모든 값을 가질 수 있음을 어떻게 명시해야 하나요?\n여기서 예를 들어보겠습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> someArray<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// 몇가지 값을 추가</span>\nsomeArray<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nsomeArray<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello'</span><span class=\"token punctuation\">)</span>\nsomeArray<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> age<span class=\"token operator\">:</span> <span class=\"token number\">42</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nsomeArray<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>잠재적으로 사용 가능 하고 모든 타입을 포함할 수 있는 배열을 만들고 있습니다.\n최고의 코드는 아닐 수도 있지만 그냥 진행해보겠습니다.\n숫자, 문자열, 객체를 추가합니다.\n이제 아래 코드를 보고 어떤 일이 발생할지 생각해 봅시다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> someArray<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// ... 값을 추가</span>\nsomeArray<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이 코드는 실제로 유효한 TypeScript이며 문제 없이 컴파일됩니다.\n그러나 런타임에서는 실패합니다.\n왜 그렇죠?\n<code class=\"language-text\">null</code> 또는 <code class=\"language-text\">undefined</code> 항목을 반복하고 <code class=\"language-text\">.age</code>에 접근하려고 하면 다음과 같은 에러가 발생하기 때문입니다:</p>\n<p><code class=\"language-text\">Uncaught TypeError: Cannot read properties of null.</code> <small>Uncaught TypeError: null 속성을 읽을 수 없습니다.</small></p>\n<p>TS 컴파일러가 코드는 괜찮다고 말한 후라서 여러분은 제대로 작동하기를 기대하기 때문에, 이건 일종의 잘못된 보안이라고 생각합니다.</p>\n<p>하지만 고칠 수 있습니다! 그리고 변경은 실제로 매우 간단합니다.\n동일한 코드를 사용하는 경우 다음과 같이 배열을 <code class=\"language-text\">Array&lt;any></code>로 입력하는 대신 <code class=\"language-text\">Array&lt;unknown></code>을 사용하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> someArray<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">unknown</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// ... 값을 추가</span>\n\nsomeArray<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>그러면 이 코드는 컴파일되지 않습니다!\n대신에 TypeScript는 <code class=\"language-text\">entry.age</code>에 접근하려고 할 때 다음과 같은 에러를 표시합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ... 다른 코드</span>\n\nsomeArray<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 객체가 'unknown' 타입입니다.</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">unknown</code>을 사용하면 값이 <code class=\"language-text\">unknown</code>인 것이 작업을 수행하기 전에 타입을 확인(또는 명시적으로 값 캐스팅)을 하게 강제합니다.\n예를 들어보겠습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// ... 다른 코드</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Human</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span>\n\nsomeArray<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 만약 객체라면 그것이 Human이라는 것을 알 수 있습니다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> entry <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>entry <span class=\"token keyword\">as</span> Human<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이 사례에서 값이 객체인지 확인한 다음 <code class=\"language-text\">.age</code> 속성에 접근합니다.\n그리고 이것은 매우 추상적인 주제이기 때문에, 여기서 간단히 줄이겠습니다:</p>\n<blockquote>\n<p>”<code class=\"language-text\">any</code>는 기본적으로 TypeScript 컴파일러가 해당 코드 비트를 확인하지 않는다는 의미입니다. 가능하면 <code class=\"language-text\">any</code>를 사용하지 마세요! 대신 <code class=\"language-text\">unknown</code>을 사용하는 것이 좋습니다. 값을 사용하기 전에 타입을 확인하게 강제 하기 때문입니다. 그렇지 않으면 컴파일되지 않습니다!”</p>\n</blockquote>\n<p><strong>참고</strong>: 유효한 객체인지 확인하는 데 <code class=\"language-text\">typeof x === 'object'</code>를 사용하지 마세요. 배열도 <code class=\"language-text\">true</code>를 반환하기 때문입니다.</p>\n<h2 id=\"세-번째-typing-objects-with-records\" style=\"position:relative;\"><a href=\"#%EC%84%B8-%EB%B2%88%EC%A7%B8-typing-objects-with-records\" aria-label=\"세 번째 typing objects with records permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세 번째: Typing Objects with Records</h2>\n<p>TS를 처음 사용하기 시작했을 때 다음과 같은 해결책을 기억할 수 없었기 때문에 항상 구글에 객체 타입 방법을 검색해야 했습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Human<span class=\"token operator\">:</span> Person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'Steve'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이것은 TS에서 객체 타입을 정하는 유효한 해결책이지만 외우기가 상당히 어렵고 또한 매우 제한적이라고 생각합니다.</p>\n<p>예를 들어 특정 키만 허용하려면 다음과 같은 문자열 유니언을 만듭니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">AllowedKeys</span> <span class=\"token operator\">=</span> <span class=\"token string\">'name'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'age'</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">[</span>key<span class=\"token operator\">:</span> AllowedKeys<span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> Human<span class=\"token operator\">:</span> Person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'Steve'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그러나 TypeScript는 이것을 좋아하지 않으며 다음과 같은 에러를 발생시킵니다:</p>\n<p><code class=\"language-text\">An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.</code>\n<small>인덱스 시그니쳐 매개 변수 타입은 리터럴 타입 또는 제네릭 타입일 수 없습니다. 대신 매핑된 객체 타입을 사용하는 것이 좋습니다.</small></p>\n<p>음, 뭐라고요? 이것은 다시 IDE를 닫고 일반 JS로 돌아가도록 만드는 TypeScript 에러 중 하나입니다.\n그러나 코드를 훨씬 더 읽기 쉽게 만드는 해결책이 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">AllowedKeys</span> <span class=\"token operator\">=</span> <span class=\"token string\">'name'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'age'</span>\n\n<span class=\"token comment\">// interface 대신 여기에 type을 사용하세요.</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Person</span> <span class=\"token operator\">=</span> Record<span class=\"token operator\">&lt;</span>AllowedKeys<span class=\"token punctuation\">,</span> <span class=\"token builtin\">unknown</span><span class=\"token operator\">></span>\n\n<span class=\"token keyword\">const</span> Human<span class=\"token operator\">:</span> Person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'Steve'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">42</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>새로운 type을 정의할 수 있도록 interface에서 type으로 변경하기만 하면, 두 개의 제네릭 매개 변수를 사용하는 키워드 <code class=\"language-text\">Record</code>를 사용할 수 있습니다. 여기서 첫 번째는 key이고 두 번째는 해당 value입니다.\n아주 간단하죠? 그런데 지금 <code class=\"language-text\">AllowedKeys</code>에 값을 추가하면 <code class=\"language-text\">Human</code> 객체에 에러가 발생합니다. 이유는 바로 그러한 속성이 없기 때문인데, 제 생각엔 꽤 멋진 것 같아요!</p>\n<h2 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h2>\n<p><a href=\"https://www.cstrnt.dev/blog/three-typescript-tricks\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">3 TypeScript Tricks I wish I knew when I learned TypeScript</a></p>\n<h2 id=\"번역의-변\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%97%AD%EC%9D%98-%EB%B3%80\" aria-label=\"번역의 변 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번역의 변</h2>\n<p>기존까진 한가지 문체로 번역을 해왔고 또 하고 싶었으나 경험상 하나의 문체로만 번역하기엔 매끄럽지 못하다고 판단이 들었다.\n그리하여 하십시오체를 기본으로 하고 해요체를 섞어 사용했으며 앞으로도 그렇게 진행하려고 한다.</p>","frontmatter":{"title":"Typescript를 배웠을 때 알았으면 좋았을 3가지 트릭","date":"2021-10-27","description":"[번역] 3 TypeScript Tricks I wish I knew when I learned TypeScript","tags":"typescript"}}},"pageContext":{"slug":"/blog/2021/3-typescript-tricks/","previous":{"fields":{"slug":"/blog/2021/how-javascript-works-visually-explained/"},"frontmatter":{"title":"JavaScript 작동 방식 (시각적으로 설명)"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-smallexecution-contextsmall\">실행 컨텍스트 <small>Execution Context</small></a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#javascript%EC%9D%98-%EB%AA%A8%EB%93%A0-%EA%B2%83%EC%9D%80-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%95%88%EC%97%90%EC%84%9C-%EC%9D%BC%EC%96%B4%EB%82%A9%EB%8B%88%EB%8B%A4\">“JavaScript의 모든 것은 실행 컨텍스트 안에서 일어납니다.”</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89\">코드 실행</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%ED%95%A8%EC%88%98%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%98%B8%EC%B6%9C%EB%90%A9%EB%8B%88%EA%B9%8C\">실행 컨텍스트에서 함수는 어떻게 호출됩니까?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%BD%9C-%EC%8A%A4%ED%83%9D-smallcall-stacksmall\">콜 스택 <small>Call Stack</small></a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B6%9C%EC%B2%98\">출처</a></p>\n</li>\n</ul>"},"next":null}},
    "staticQueryHashes": ["1137390604","3980716358"]}