{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/2021/why-rust-is-a-modern-programming-language/",
    "result": {"data":{"site":{"siteMetadata":{"title":"lannex"}},"markdownRemark":{"id":"b0fa3a9d-feb2-52d5-8527-94c5d5298b64","excerpt":"소개 Rust는 garbage-collector…","html":"<h2 id=\"소개\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EA%B0%9C\" aria-label=\"소개 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소개</h2>\n<p><a href=\"https://www.rust-lang.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rust</a>는 <strong>garbage-collector</strong>가 필요 없이 <em>메모리 안전성</em>과 <em>동시성</em>을 위해 디자인된 컴파일 언어에, <em>정적 타입</em>이며, <em>멀티 패러다임</em>인 <strong>현대적인</strong> 프로그래밍 언어입니다.</p>\n<h2 id=\"현대적인이-무슨-뜻입니까\" style=\"position:relative;\"><a href=\"#%ED%98%84%EB%8C%80%EC%A0%81%EC%9D%B8%EC%9D%B4-%EB%AC%B4%EC%8A%A8-%EB%9C%BB%EC%9E%85%EB%8B%88%EA%B9%8C\" aria-label=\"현대적인이 무슨 뜻입니까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>“현대적인”이 무슨 뜻입니까?</h2>\n<p>물론, 저는 관심을 끌기 위해 <em>현대적인</em> 이라는 단어를 사용했습니다. 이 용어는 주관적이며 제가 “현대적인”이라고 생각하는 많은 기능은 실제로 다른 언어에서 빌린 개념입니다 (나중에 자세히 설명).</p>\n<p>하지만, 이 언어를 진정 현대적으로 만드는 것은 의존성 관리, 빌드, 테스트 등에 대한 지원을 제공하는 <em>엄선된</em> 기능들과 <em>cargo</em> 생태계입니다.</p>\n<h2 id=\"정적-타입\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%A0%81-%ED%83%80%EC%9E%85\" aria-label=\"정적 타입 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적 타입</h2>\n<p>논쟁의 여지가 없는 것부터 시작해 봅시다. 정적 타입이란 컴파일 시 데이터 타입을 알고 있음을 의미합니다.</p>\n<p>Rust는 프로그램이 실행되기 <strong>전에</strong> 가능한 한 많은 문제를 <em>찾아</em> 컴파일 단계에서 해결하려고 합니다. 컴파일 시 데이터 타입을 알면 바로 그렇게 할 수 있습니다. 하지만 그렇다고 장황할 필요는 없습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u32</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 부호없는 32 비트 정수로 명시적으로 선언된 타입</span>\n<span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// y의 타입도 u32, 하지만 컴파일러에 의해 유추됩니다.</span></code></pre></div>\n<h2 id=\"메모리-안전성\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%95%88%EC%A0%84%EC%84%B1\" aria-label=\"메모리 안전성 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 안전성</h2>\n<p>Rust는 <em>올바른</em> 프로그램을 작성하는 것을 확실히 하길 원합니다.\nRust는 댕글링 (잘못된) 포인터를 역 참조하지 않고 초기화되지 않은 메모리에 액세스하지 않을 것입니다 (나중에 자세히 설명).\n스코프를 벗어나면 C ++의 RAII와 유사하게 메모리가 해제됩니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">std<span class=\"token punctuation\">::</span>fs<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">File</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 파일 시스템 상호 인터랙션을 담당하는 모듈에서 \"import\"</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 리소스를 확보</span>\n  <span class=\"token keyword\">let</span> fileHandler <span class=\"token operator\">=</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">::</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"foo.txt\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//... do stuff with out file</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// fileHandler가 스코프를 벗어나면 메모리가 해제됩니다.</span></code></pre></div>\n<p>또한 Rust가 스코프를 벗어난 이름을 참조하도록 허용하지 않는다는 것도 좋은 점입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">add</span><span class=\"token punctuation\">(</span>first <span class=\"token punctuation\">:</span> <span class=\"token keyword\">u32</span><span class=\"token punctuation\">,</span> second <span class=\"token punctuation\">:</span> <span class=\"token keyword\">u32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">u32</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> frist <span class=\"token operator\">+</span> second<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>result<span class=\"token punctuation\">;</span> <span class=\"token comment\">// error</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 여기서 result는 해제됩니다.</span></code></pre></div>\n<p>실행이 <code class=\"language-text\">add</code> 스코프를 벗어나면  <code class=\"language-text\">result</code> 가 할당 해제되며 (&#x26; 연산자를 통해) 참조를 반환하는 것은 유효하지 않습니다. (이 코드에서 다루지 않는 reference lifetimes 라는 것이 필요합니다.)</p>\n<h2 id=\"현대적인\" style=\"position:relative;\"><a href=\"#%ED%98%84%EB%8C%80%EC%A0%81%EC%9D%B8\" aria-label=\"현대적인 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>“현대적인”</h2>\n<p>여기가 제가 가장 좋아하는 부분입니다. 앞서 말했듯이, 이러한 많은 기능들은 다른 언어로부터 영감을 받았습니다.  Rust는 많은 언어에 영향을 받아 실수에서 배우고 반복하지 않습니다. 함수형 프로그래밍에서 기능을 차용하지만 멀티 패러다임 개발을 지원하는 다음과 같은 <em>엄선된</em> 기능들로 빛을 발합니다.</p>\n<h3 id=\"비구조화-destructuring\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EA%B5%AC%EC%A1%B0%ED%99%94-destructuring\" aria-label=\"비구조화 destructuring permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비구조화 (Destructuring)</h3>\n<p>이것은 자바스크립트와 비슷해서 익숙할 수도 있습니다. 3D 포인트가 있다고 해봅시다, <code class=\"language-text\">Point3D</code></p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">// x,y,z 3D 축에 해당하는 3개의 부호가 없는 정수를 가진 소위 \"튜플 구조체\"</span>\n<span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Point3D</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">u8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>비구조화를 통해 우리가 관심있는 값만 가져올 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> three_d <span class=\"token operator\">=</span> <span class=\"token class-name\">Point3D</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> three_d<span class=\"token punctuation\">;</span>\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2D 좌표는 x: {} and y: {}\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"패턴-매칭-pattern-matching\" style=\"position:relative;\"><a href=\"#%ED%8C%A8%ED%84%B4-%EB%A7%A4%EC%B9%AD-pattern-matching\" aria-label=\"패턴 매칭 pattern matching permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>패턴 매칭 (Pattern matching)</h3>\n<p>이 기능은 소중합니다.  <code class=\"language-text\">name</code> 과 <code class=\"language-text\">age</code> 로 설명되는 <code class=\"language-text\">Person</code> 구조체가 있다고 가정해 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  name <span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span>\n  age  <span class=\"token punctuation\">:</span> <span class=\"token keyword\">u8</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>패턴 매칭으로 기존 <code class=\"language-text\">switch</code> 문에 관한 항상 꿈꿔왔던 작업을 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Jennifer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> age <span class=\"token punctuation\">:</span> <span class=\"token number\">23</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">match</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">.</span><span class=\"token function\">as_ref</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// match 연산자 패턴은 결과를 매치하는 것이며 스위치 문과 유사하며 더 고급입니다.</span>\n  <span class=\"token punctuation\">(</span><span class=\"token string\">\"Jennifer\"</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Oh, Jenn it's you, I need help with the cake, dear.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> minor<span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> minor <span class=\"token operator\">&lt;</span> <span class=\"token number\">18</span> <span class=\"token operator\">=></span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Dear {}, there's some RobbyBubble for you.\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> major<span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> major <span class=\"token operator\">>=</span> <span class=\"token number\">18</span> <span class=\"token operator\">=></span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Dear {}, there's some champain for you.\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  _ <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// default case</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>눈치채셨다면, 여기에도 튜플 비구조화를 사용했습니다. match 문에서 사람의 name과 age 쌍을 이룬 튜플을 만들었습니다.</p>\n<p>패턴 매칭은 정말 강력하며 <code class=\"language-text\">match</code> 문 이외에 <a href=\"https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">if let</a>과 같은 것으로 응용됩니다.</p>\n<h3 id=\"기본적으로-불변성--섀도잉-immutability-by-default--shadowing\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%B6%88%EB%B3%80%EC%84%B1--%EC%84%80%EB%8F%84%EC%9E%89-immutability-by-default--shadowing\" aria-label=\"기본적으로 불변성  섀도잉 immutability by default  shadowing permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본적으로 불변성 &#x26; 섀도잉 (Immutability by default &#x26; shadowing)</h3>\n<p>Rust의 변수는 기본적으로 <em>불변</em>입니다. <a href=\"https://en.wikipedia.org/wiki/Haskell_(programming_language)\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Haskell</a> 또는 <a href=\"https://en.wikipedia.org/wiki/Racket_(programming_language)\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Racket</a>과 같은 언어인 <a href=\"https://en.wikipedia.org/wiki/Functional_programming\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">함수형 프로그래밍 </a>의 기능처럼 상태는 변하지 않는다고 보장됩니다.</p>\n<p><em>C#/Java</em>를 예로 들자면, 이런 기능을 가지고 있지 않습니다. 기본으로 객체를 변경할 수 있는 문제는 참조 전달이 <em>내부 상태</em>를 엉망이 되지 않도록 해야한다는 것입니다.</p>\n<p>불변성은 왜 갑자기 그 리스트가 비었는지? 왜 <code class=\"language-text\">true</code> 여야한 그 bool은 사실 <code class=\"language-text\">false</code> 인지? 😑 와 같은 성가신 디버깅 상황을 방지 할 수 있습니다.</p>\n<p>이것은 보통 좋은 <a href=\"https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">캡슐화</a>로 해결되지만 항상 가능한 것은 아닙니다. 특히 서드 파티 코드를 사용할 때는 사용자가 잘 제어할 수 없습니다.</p>\n<p>또한, Rust는 섀도잉이라는 깔끔한 기능으로 다음과 같은 작업을 수행할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token comment\">// 가변 변수 명시적으로 \"mut\" 키워드로 표시</span>\n<span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> p <span class=\"token operator\">=</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">:</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> age <span class=\"token punctuation\">:</span> <span class=\"token number\">24</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// name 읽기</span>\n<span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Please enter your name: \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// stdin에서 읽을 가변 name 전달</span>\n<span class=\"token namespace\">std<span class=\"token punctuation\">::</span>io<span class=\"token punctuation\">::</span></span><span class=\"token function\">stdin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">read_to_string</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> p<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"shadow\" 이전 p name, 불변으로 재정의</span>\n<span class=\"token punctuation\">...</span></code></pre></div>\n<p>마지막 구문에서, 우리는 <code class=\"language-text\">p</code>의 상태를 망치는 게 아무것도 없다는 것을 압니다. 왜냐하면 거기부터 <em>불변</em>이기 때문입니다. ✔</p>\n<h3 id=\"no-null\" style=\"position:relative;\"><a href=\"#no-null\" aria-label=\"no null permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>No null!</h3>\n<p>제가 Rust를 “현대적”이라고 부르는 또 다른 이유로 null 참조가 없기 때문입니다. <a href=\"https://en.wikipedia.org/wiki/Tony_Hoare\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tony Hoare</a>는 null 참조를 그의</p>\n<blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">billion-dollar 실수</a></p>\n</blockquote>\n<p>라고 했습니다.</p>\n<p>Rust는 간단하게 <code class=\"language-text\">null</code> 이나 다른 비슷한 키워드를 가지고 있지 않습니다.\n대신 optional로 값이 없음을 설명합니다 (<a href=\"https://en.wikipedia.org/wiki/Option_type\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">optional type</a> 보기). generic을 통해 이를 달성하며 예를 들자면:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> can_have_number <span class=\"token punctuation\">:</span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">u32</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Option</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">match</span> can_have_number  <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"We have the number: {}\"</span><span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">None</span> <span class=\"token operator\">=></span> <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"There is no number to print!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>옵션 안에 모든 타입의 데이터를 감쌀 수 있으며, 유저는 두 가지 경우를 모두 처리해야 합니다.\n데이터가 있을때, <code class=\"language-text\">Some</code> 안에 감싸져 있거나 데이터가 없을때. 더 잘 이해하기 위해 generic과 enum에 대해 이야기하겠습니다.</p>\n<h3 id=\"일급-열거형enum-지원\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EA%B8%89-%EC%97%B4%EA%B1%B0%ED%98%95enum-%EC%A7%80%EC%9B%90\" aria-label=\"일급 열거형enum 지원 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일급 열거형(Enum) 지원</h3>\n<p><em>enum</em>을 사용해 본 적이 있다면 아마 C 스타일 enum에 익숙할 것입니다.\n그러나 Rust에서는 어떤 심볼이나 정수 값 <em>enum</em>의 역할 이외에도 그것들과 <em>관련 값</em>을 가질 수 있습니다.</p>\n<p>앞에서 본 <em>Option</em> 타입은 일반적으로 다음과 같이 정의 할 수있는 <code class=\"language-text\">enum</code> 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">enum</span> <span class=\"token type-definition class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">Some</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">T</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token class-name\">None</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Option</code> 은 <code class=\"language-text\">Option::Some(T)</code> 와 <code class=\"language-text\">Option::None</code> 를 가집니다.</p>\n<p><code class=\"language-text\">Some</code> 은 값의 존재를 설명합니다. <code class=\"language-text\">None</code> 은 그것이 없음을 설명합니다. <code class=\"language-text\">None</code> 의 경우, 연관 값이 없기 때문에 “여기에 아무것도 없습니다.” 라고 말하는 것으로 충분합니다. 하지만 <code class=\"language-text\">Some</code> 은 단지 “여기에 뭔가가 있습니다.”라고 말하는 것이 아닙니다. 또한 실제로 데이터를 저장하고 제공하고 있습니다.\n여러분은 이것이 패턴 매칭의 또 다른 활용 사례인지 알 수 있습니까?</p>\n<h2 id=\"특성-traits\" style=\"position:relative;\"><a href=\"#%ED%8A%B9%EC%84%B1-traits\" aria-label=\"특성 traits permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특성 (Traits)</h2>\n<p>Trait는 Java / C #의 interface와 유사하며 <em>struct</em>가 <em>기능</em>을 구현하고 struct 타입을 interface 타입으로 참조할 수 있게 함으로써 다형성을 허용합니다.\n그것들의 <em>차이</em>로 <em>trait</em>는 <em>제어할 수 없는</em> 타입에 구현될 수 있다는 점입니다.</p>\n<p>고유 한 사진 뷰어 어플리케이션에 <em>서드 파티</em> JPEG 라이브러리를 사용한다고 상상해보십시오.\n이 프로그램은 이미 <code class=\"language-text\">Photo</code> 라는 trait을 사용하여 PNG, 비트맵 및 기타 형식을 지원합니다. 만약 JPEG 라이브러리가 그것에 대해 알고 있었다면! 😑\n아마 Rust에서 당신은 라이브러리가 제공하는 JPEG 구조에 대해 <code class=\"language-text\">Photo</code> trait를 <em>구현</em>할 수 있습니다!</p>\n<p>더군다나 <code class=\"language-text\">u8</code>, <code class=\"language-text\">String</code> 등과 같은 내장 Rust 데이터 타입에 대해 자체적으로 작성된 trait을 구현할 수도 있습니다. ✔</p>\n<h2 id=\"결론\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론</h2>\n<p><em>대여 (borrowing)</em>, 다중 스레딩 및 많은 제로 코스트 추상화와 같은 <strong>풍부한</strong> 다른 기능들과 함께 Rust는 무료 / 오픈 소스 현대적인 언어입니다.</p>\n<p>Mozilla 제단에서 개발된 이 프로그래밍 언어는 시스템 프로그래밍(내장된 <a href=\"https://www.theregister.com/2020/07/13/rust_code_in_linux_kernel/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">커널 프로그래밍</a>에서 <a href=\"https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">웹 어셈블리</a>를 통해 웹 앱에 이르기까지 모든 종류의 소프트웨어를 지원합니다.</p>\n<p>Rust에 관심이 있으시다면 무료 <a href=\"https://doc.rust-lang.org/book/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rust book</a>을 추천합니다.</p>\n<h2 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h2>\n<p><a href=\"https://dev.to/stoiandan/why-rust-is-a-modern-programming-language-1hc6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Why Rust is a “modern” programming language</a></p>","frontmatter":{"title":"Rust가 '현대적인' 프로그래밍 언어인 이유","date":"2021-01-01","description":"[번역] Why Rust is a \"modern\" programming language","tags":"rust"}}},"pageContext":{"slug":"/blog/2021/why-rust-is-a-modern-programming-language/","previous":{"fields":{"slug":"/blog/2020/EFK-Fluentd-Fluentbit/"},"frontmatter":{"title":"EFK Stack, 그 중에 Fluentd와 Fluent Bit"},"tableOfContents":"<ul>\n<li><a href=\"#-elk%EC%99%80-efk-stack\">👀 ELK와 EFK Stack?</a></li>\n<li><a href=\"#-architecture\">📐 Architecture</a></li>\n<li><a href=\"#-fluent-bit%EA%B3%BC-fluentd\">🤲 Fluent Bit과 Fluentd</a></li>\n<li><a href=\"#-input--parser--filter--output\">👉 Input → Parser → Filter → Output</a></li>\n<li><a href=\"#-forwarder-fluent-bit\">🚢 Forwarder (Fluent Bit)</a></li>\n<li><a href=\"#-aggregator-fluentd\">🗃 Aggregator (Fluentd)</a></li>\n<li><a href=\"#-elasticsearch%EC%99%80-kibana\">📊 Elasticsearch와 Kibana</a></li>\n<li><a href=\"#-%EB%81%9D%EC%9C%BC%EB%A1%9C\">📃 끝으로</a></li>\n</ul>"},"next":{"fields":{"slug":"/blog/2021/building-a-scalable-e-commerce-data-model/"},"frontmatter":{"title":"확장 가능한 이커머스 데이터 모델 구축"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C\">시작하기에 앞서</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B4%EC%BB%A4%EB%A8%B8%EC%8A%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8\">이커머스 데이터 모델</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B3%A0%EA%B0%9D%EC%9D%80-%EB%88%84%EA%B5%AC%EC%9E%85%EB%8B%88%EA%B9%8C\">고객은 누구입니까?</a></p>\n<ul>\n<li><a href=\"#%EA%B9%8A%EC%9D%B4-%EC%9E%88%EA%B2%8C-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-addresses\">깊이 있게 들어가기: Addresses</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%9C%ED%92%88%EA%B3%BC-%EC%B9%B4%ED%83%88%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EA%B5%AC%EC%84%B1%ED%95%A9%EB%8B%88%EA%B9%8C\">어떻게 제품과 카탈로그를 구성합니까?</a></p>\n<ul>\n<li><a href=\"#%EA%B9%8A%EC%9D%B4-%EC%9E%88%EA%B2%8C-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-pricing\">깊이 있게 들어가기: Pricing</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A3%BC%EB%AC%B8%EC%9D%84-%EA%B0%84%EC%86%8C%ED%99%94%ED%95%A9%EB%8B%88%EA%B9%8C\">어떻게 주문을 간소화합니까?</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A4%EB%A5%B8-%EB%B0%A9%EB%B2%95-fabric\">다른 방법 (Fabric)</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B6%9C%EC%B2%98\">출처</a></p>\n</li>\n</ul>"}}},
    "staticQueryHashes": ["1137390604","3980716358"]}