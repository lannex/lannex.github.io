{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog/2022/ddd-hexagonal-onion-clean-cqrs/","result":{"data":{"site":{"siteMetadata":{"title":"lannex"}},"markdownRemark":{"id":"51dee2b1-cf65-5375-850f-84ee06e0b351","excerpt":"이 포스트는 소프트웨어 아키텍처에 관한 시리즈인 소프트웨어 아키텍처 연대기(The Software Architecture Chronicles…","html":"<p>이 포스트는 <a href=\"%22https://herbertograca.com/category/development/series/software-architecture/%22\">소프트웨어 아키텍처에 관한 시리즈</a>인 <a href=\"%22https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/%22\">소프트웨어 아키텍처 연대기(The Software Architecture Chronicles)</a>의 일부입니다. 해당 포스트들에서 저는 소프트웨어 아키텍처에 대해 배운 내용과 그것을 제가 어떻게 생각하며, 배운 지식을 실제로 어떻게 사용하는지에 대해 글을 씁니다. 이 포스트의 내용은 이 시리즈의 이전 포스트들을 읽으면 더 쉽게 이해할 수 있을 것입니다.</p>\n<p>대학을 졸업한 후 저는 고등학교 교사로 일하다가, 몇 년 전 이 일을 그만두고 정식으로 소프트웨어 개발자가 되기로 결심했습니다.</p>\n<p>그때부터 저는 항상 “잃어버린 시간”을 되찾아야 한다는 생각에, 가능한 한 빠르고 많은 것을 배워야 한다고 느꼈습니다. 그래서 특히 소프트웨어 디자인과 아키텍처 분야에 빠져들어 실험하고 읽고 쓰는 일에 중독되었습니다. 제가 이 포스트를 쓰는 이유도 바로 그렇게 배우는 과정에 도움을 주기 때문입니다.</p>\n<p>지난 포스트들에서 제가 배운 많은 개념과 원칙들, 그리고 그것들에 대한 제 생각을 다뤘습니다. 하지만 저는 이 모든 것들이 하나의 큰 퍼즐을 이루는 조각들에 불과하다고 봅니다.</p>\n<p>오늘 포스트는 제가 이 퍼즐 조각들을 어떻게 맞추는지에 관한 것입니다. 그리고 여기에 이름을 붙여야 할 것 같아서 저는 이를 명시적 아키텍처(Explicit Architecture) 라 부르기로 했습니다. 또한 여기서 소개할 개념들은 이미 실제 환경에서 “전투 시험”을 통과했으며, 높은 요구사항을 가진 프로덕션 코드에서도 성공적으로 사용되고 있습니다. 한 가지는 전 세계 수천 개의 웹 상점을 운영하는 SaaS 전자상거래 플랫폼이며, 다른 하나는 두 국가에서 운영되고 월 2천만 건 이상의 메시지를 처리하는 메시지 버스를 사용하는 마켓플레이스 플랫폼입니다.</p>\n<h2 id=\"시스템의-기초-블록\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B8%B0%EC%B4%88-%EB%B8%94%EB%A1%9D\" aria-label=\"시스템의 기초 블록 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시스템의 기초 블록</h2>\n<p>먼저 <a href=\"%22https://herbertograca.com/2017/08/24/ebi-architecture/%22\">EBI(Entity-Boundary-Interactor)</a>와 <a href=\"%22https://herbertograca.com/2017/09/14/ports-adapters-architecture/%22\">포트 &#x26; 어댑터(Ports &#x26; Adapters)</a> 아키텍처부터 떠올려 봅시다. 두 가지 모두 애플리케이션 내부 코드와 외부 코드, 그리고 이 둘을 연결하는 코드를 명확하게 구분합니다.</p>\n<p>특히 <a href=\"%22https://herbertograca.com/2017/09/14/ports-adapters-architecture/%22\">포트 &#x26; 어댑터 아키텍처</a>는 시스템에서 세 가지 기본적인 코드 블록을 명시적으로 정의합니다.</p>\n<ul>\n<li>사용자 인터페이스(User Interface)\n어떤 형태의 사용자 인터페이스든 작동 가능하게 하는 코드입니다.</li>\n<li>시스템 비즈니스 로직, 즉 애플리케이션 코어(Application Core)\n사용자 인터페이스가 실제로 일을 수행하기 위해 호출하는 핵심 코드입니다.</li>\n<li>인프라스트럭처(Infrastructure) 코드\n애플리케이션 코어를 데이터베이스나 검색 엔진, 서드파티 API와 같은 도구들과 연결하는 코드입니다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fa430d20e7a028964f6d24b108445b3b/29007/000-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAABqElEQVR42qXT3U/TYBTH8f3fXnHjjZAQkQBuviSoSHCZIXIjJmZjG6wvWwez7VAyhISMsZeWdXatSb+c1miMLDAw6S/P3afnec45qWbngFvTruNWVwmVpwRq5sakboTO92leyNlt4BqvCbXMf4Ax1rewzgysozKDYpqgsEBYfXEPUDC7Z2LaRc7ybxlqWUbKOt6nNN6HRwTaszuAcWWC2WaeQWkdnAoEdcl+knE1y3BzlrAmlSrp6UBrYHNc2IDeLtGoRuQoAqsSOX828D5n8PMLBPrz28HD3hfMowpd9T2MqkSuQJdakihGx3X5coy25+U9pwG7Ah6rAubA0/8BlQT0a9npwaQhTpNW4R10ikS+8QscxhE8OMDbXsHfWZzuyklTpEr7a5mL/BqRoLhK8n7Rpc6P8hu8rbk7NOWvTlty9e8fX3G68pD24wf0X84kVw10GRvlPoMdj0+ngdlS6BczhKVFQmNyZX9AS/Y0ziTUFrR+qmKeGziyesOdJ/h71/c5lEH/nZTWKlH5VsA4qUxETfmZ3TZw9VXGe8uMJ1TllZZwZC7j8wqErs+5fOlAcQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"000\"\n        title=\"\"\n        src=\"/static/fa430d20e7a028964f6d24b108445b3b/5a190/000-explicit-architecture-svg.png\"\n        srcset=\"/static/fa430d20e7a028964f6d24b108445b3b/772e8/000-explicit-architecture-svg.png 200w,\n/static/fa430d20e7a028964f6d24b108445b3b/e17e5/000-explicit-architecture-svg.png 400w,\n/static/fa430d20e7a028964f6d24b108445b3b/5a190/000-explicit-architecture-svg.png 800w,\n/static/fa430d20e7a028964f6d24b108445b3b/c1b63/000-explicit-architecture-svg.png 1200w,\n/static/fa430d20e7a028964f6d24b108445b3b/29007/000-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>우리가 정말 중요하게 생각해야 할 부분은 바로 애플리케이션 코어입니다. 이곳에 있는 코드가 바로 우리의 애플리케이션이며, 이 코드가 존재해야만 애플리케이션이 해야 하는 일들을 수행할 수 있습니다. 애플리케이션은 다양한 사용자 인터페이스(프로그레시브 웹 앱, 모바일 앱, CLI, API 등)를 통해 호출될 수 있지만, 실제 작업을 수행하는 코드는 모두 동일하며 애플리케이션 코어 안에 위치합니다. 따라서 어떤 UI가 작업을 시작하는지는 크게 중요하지 않습니다.</p>\n<p>예상할 수 있듯, 일반적인 애플리케이션의 흐름은 다음과 같습니다.</p>\n<ul>\n<li>사용자 인터페이스에서 시작된 요청이</li>\n<li>애플리케이션 코어를 거쳐</li>\n<li>인프라스트럭처 코드로 전달된 후</li>\n<li>다시 애플리케이션 코어로 돌아와서 최종적으로 처리된 응답을</li>\n<li>사용자 인터페이스에 전달합니다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b41fa5c890b0932fc12186abf44d7cb0/29007/010-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAACSUlEQVR42pWT2U8TURSH+3/75IsPxkTjErQtSwKIiTaIARKRInaBMp1Op9PZute2lBboMlhkpoift60hEhD04cs9T989957z8+UOs9xJK4OjzDOU/HjJ4K34bhW1NXJH4jzWcdRFhnLwbqHZzFwKrPYEW9S2kNldC7OpYhV26EYDuF+e4SmzuMlpQXDMNaHRUMeyvOik2stQ6mREnaHQM8jno7SjS3xX3uHKb3C3/LjrD7lIveJC9vNDvv4FvnQxORbqTZ1QssSWaaM0bJJagko4hHOQwhHybtfk6NiivL2KFZqhshPiMD4vJIGrQr2eFl1lMVsTYdjIsdcoIH9aZ7+sUNs3qFdV9msqrbpCz7FpbS7Q3gyQj76nHHk77tS9fHItzW5JJ1HW0RoZ0Z2OZCToJEPgpfg5kGCQnHAi6qGKlwnhbT6mJy2ibX24KsyJISi1LGuqzYqSYzmVJxTTkD+HKX/VKZQ0iuXsmJKoy3ULKxbGWF3EiqzgJOYY/vFsn1FXKR5PhmK1dawDDb2bJ7e9jNfcwRtoeL0U5/0RMuenOp2PQQaRKS6UwBXZWGgdTNZmtCr5MRr5jkGuGKcTWYKjGDjiqX3BSYqz3decrj1imJ7Blf51sUcL3TExq0mqGws0/A9oPb1Hd+4+pxtPxNdO40n/m5TfUvtQx6xIdGNBhvEXYiazQhb4e1IskdMRN0lHacnUJcy2Sj+9yLfoc84S15d5KE9f4pMrcfaKEdTa3o1SU1xmt1Sc1Dxu4uWNcRvEp+iLWI7OX30/yUIMGVxUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"010\"\n        title=\"\"\n        src=\"/static/b41fa5c890b0932fc12186abf44d7cb0/5a190/010-explicit-architecture-svg.png\"\n        srcset=\"/static/b41fa5c890b0932fc12186abf44d7cb0/772e8/010-explicit-architecture-svg.png 200w,\n/static/b41fa5c890b0932fc12186abf44d7cb0/e17e5/010-explicit-architecture-svg.png 400w,\n/static/b41fa5c890b0932fc12186abf44d7cb0/5a190/010-explicit-architecture-svg.png 800w,\n/static/b41fa5c890b0932fc12186abf44d7cb0/c1b63/010-explicit-architecture-svg.png 1200w,\n/static/b41fa5c890b0932fc12186abf44d7cb0/29007/010-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 id=\"도구\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EA%B5%AC\" aria-label=\"도구 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도구</h2>\n<p>우리 시스템의 핵심인 애플리케이션 코어로부터 멀리 떨어져 있는 곳에는 애플리케이션에서 사용하는 여러 가지 도구들이 있습니다. 예를 들어 데이터베이스 엔진, 검색 엔진, 웹 서버 또는 CLI 콘솔 같은 것들입니다. (물론 웹 서버와 CLI는 전달 메커니즘(delivery mechanism)으로도 분류됩니다.)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/32a9368e180a6538a0b8cc80f4659ef9/29007/020-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAACh0lEQVR42oWUW1PTUBSF87998sUXdQbEC6W0XlCRUcRR0FFgpHeSk6RpG5K05VYq0JZCbylpUu1yn7QwVuo40zU7D8l39t5rnQr5Wg7/VSWDlroAT5qDy+Ynqjeqgkkv75xok0HVLPJnVOs6WtorePL8P4F9Noe+FICgl1UYZWUy7MKESYeZe0k04kG40Rl46tPxziSq1LkVfw8juUbAkgprn6FY3xmDWecGDCuOk8gbdORldKUl2BtB2Kt34cohAgXxUw3jdGMa1c0ptKUXOE89h6AWt2EdxyGbKVi8qxqJYJYRQSOxBDRFwM2Qsr566jI6H+/BJVifwI3YI1QjT/xnPraQO1JgHDPIhRT4PgsENRsWDqNvQUdi0E1j0JQIzEhU+zrs7/NwIjNwlTB+KSHsbYZQT9AeacdCrpSGXs6heD4amaqxJ6LOPgBdFYMWgdqyrwGH9jL0W0F3fYr2Gfb32E48hiMG4Pkun2ZgnGav91egXRqHjIArgK38BZR8oJNeHgP2WAiXLAyHDBIKZ/q4IRUypJnHQfQdUItj4GhDYIeL4G4O9noADu3Oo5EdMYhoLILVLYaT1CK5fKRCLSchFmLU6SiPdIBVTOIssogBQdGS/P0N2gouk69hr92Hl6b4kNPc7R/yJxxLPAkhCAYfuZKGVmIjl0cZJKdNGr307SXKgTuoPLiFi2e3/VFdMsKVhjnkYfekWehyArvsy3DkK90INo9PTYdxIOEiTh8maExt2NlVsLkRvLOUxGCKX4dXjytfvXn1eMeZMoNR1dCkq9eJPYSzPX6fvZEpOTWJffYZgnyQgLgbhXYkTrzPBh1mVTS0lAX0tmev/wT+lE2xaW1N+/U3UhrMjd1cZGsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"020\"\n        title=\"\"\n        src=\"/static/32a9368e180a6538a0b8cc80f4659ef9/5a190/020-explicit-architecture-svg.png\"\n        srcset=\"/static/32a9368e180a6538a0b8cc80f4659ef9/772e8/020-explicit-architecture-svg.png 200w,\n/static/32a9368e180a6538a0b8cc80f4659ef9/e17e5/020-explicit-architecture-svg.png 400w,\n/static/32a9368e180a6538a0b8cc80f4659ef9/5a190/020-explicit-architecture-svg.png 800w,\n/static/32a9368e180a6538a0b8cc80f4659ef9/c1b63/020-explicit-architecture-svg.png 1200w,\n/static/32a9368e180a6538a0b8cc80f4659ef9/29007/020-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>CLI 콘솔과 데이터베이스 엔진을 같은 “양동이”에 넣는 것이 어색할 수 있지만, 목적이 서로 다르더라도 결국 애플리케이션에서 사용하는 도구라는 점은 같습니다. 주요한 차이는 다음과 같습니다.</p>\n<ul>\n<li>CLI 콘솔이나 웹 서버는 애플리케이션에게 무언가를 하라고 지시하는 역할입니다.</li>\n<li>반면, 데이터베이스 엔진은 애플리케이션으로부터 무언가를 하라는 지시를 받습니다.</li>\n</ul>\n<p>이 차이는 매우 중요합니다. 왜냐하면 이것이 바로 애플리케이션 코어와 이러한 도구들을 연결하는 코드를 작성할 때 큰 영향을 미치기 때문입니다.</p>\n<h2 id=\"도구-및-전달-메커니즘을-애플리케이션-코어와-연결하기\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EA%B5%AC-%EB%B0%8F-%EC%A0%84%EB%8B%AC-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98%EC%9D%84-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BD%94%EC%96%B4%EC%99%80-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"도구 및 전달 메커니즘을 애플리케이션 코어와 연결하기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도구 및 전달 메커니즘을 애플리케이션 코어와 연결하기</h2>\n<p>도구를 애플리케이션 코어와 연결하는 코드 단위를 어댑터(adapter) 라고 부릅니다(<a href=\"%22https://herbertograca.com/2017/09/14/ports-adapters-architecture/%22\">포트 &#x26; 어댑터 아키텍처</a>). 어댑터는 특정 도구와 비즈니스 로직 간에 양방향으로 커뮤니케이션할 수 있게 하는 코드 구현체입니다.</p>\n<p>애플리케이션에 무언가를 하라고 지시하는 어댑터를 기본 어댑터(Primary Adapter) 또는 주도하는 어댑터(Driving Adapter) 라고 하고, 애플리케이션으로부터 무언가를 하라는 지시를 받는 어댑터를 보조 어댑터(Secondary Adapter) 또는 주도되는 어댑터(Driven Adapter) 라고 합니다.</p>\n<h3 id=\"포트ports\" style=\"position:relative;\"><a href=\"#%ED%8F%AC%ED%8A%B8ports\" aria-label=\"포트ports permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>포트(Ports)</h3>\n<p>하지만 이러한 어댑터들은 무작위로 생성되는 것이 아닙니다. 각 어댑터는 애플리케이션 코어로의 특정한 진입점인 포트(Port) 를 통해 연결됩니다. 포트는 단순히 도구가 애플리케이션 코어를 사용하는 방식, 혹은 애플리케이션 코어가 도구를 사용하는 방식을 명시한 사양(specification)입니다. 대부분의 프로그래밍 언어에서는 가장 간단한 형태로 이 사양(포트)을 인터페이스(interface) 로 정의하지만, 실제로는 여러 개의 인터페이스와 DTO로 구성될 수도 있습니다.</p>\n<p>여기서 주목해야 할 중요한 점은, 포트(인터페이스)는 비즈니스 로직 내부에 속하며, 어댑터는 외부에 위치한다는 것입니다. 이 패턴이 제대로 동작하기 위해서는 도구의 API를 단순히 모방하는 것이 아니라 애플리케이션 코어의 요구사항에 맞춰 포트를 만드는 것이 매우 중요합니다.</p>\n<h3 id=\"기본-어댑터primary-또는-driving-adapters\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%96%B4%EB%8C%91%ED%84%B0primary-%EB%98%90%EB%8A%94-driving-adapters\" aria-label=\"기본 어댑터primary 또는 driving adapters permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 어댑터(Primary 또는 Driving Adapters)</h3>\n<p>기본 어댑터(주도하는 어댑터)는 포트를 감싸고(wrap) 이를 통해 애플리케이션 코어에 해야 할 작업을 전달합니다. 다시 말해, 전달 메커니즘(웹서버, CLI 등)을 통해 들어오는 데이터를 애플리케이션 코어의 메서드 호출로 변환하는 역할을 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2a2e843ffd03a9f74d165136510bd3eb/29007/030-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAADNUlEQVR42l2U2U8bdxSF/ef2f2gf+laprVRSVUlZAoUkCiRhF0ZsiQF7xrN4xmbGHhtv2MZgG5NgY4y3+uv1gCq1D0c/aR4+nXvPuRMwiwrR3DFa/hQlG8K9tsncuGSaLsVWmstmgvo3m4fzTYbJFfqJN/SNOfr67NP7rN7zG3CrMeyyTlLk5hW8C51c1eaipFJSlqk3LPJ5k4fCHuNSkFFhh2Fmjb711xPUfAINjRmG+jSB5KWNd2mRLZucXyfIirOSs8+XH75DnfmNSCjO5ttdmqF5Btosw9wGo6JAc1sM7EV68q2vz5AOr5FSdsRhySJdMMgK1Gu4XLU9apk9YmvLnB4qVA5X6MY3eNBX6BxM09n+mWFqhaE4Jb/J9dHv1I+maOuL3KqLBKxslHQ1jOFFyNc0Cs4SxewB5onFnfIeWhr0EtA/Ezk8Wqvcb/3CKLfO+CLInT5PPfSSoTnvjx1wyjFSVQM9E6VwpZE3pzg5OSKzuwrfFMYdm/GdDneGSN6hS+fzLD11hlFpl3HmE/mjOZoR2aPsM+CUbJIVh3QtReUmQevexApr1NUN6FqMWwJqm77GE6i47cXX6H7+g9HFJKB12pGXPEanGRivCXgSROr6jGTVpdyIoykqX4IqDX0dOrH/AcVhPyFjf3oGBv3EewLqGvM86uLwXDo3Sda9dKg0HT4ubfNhRfZ5KCM3w4y78Sfg/USGv8fO/itJd46/ZeRB8gMnxyG2QwZX6ntJuWxjV6Tc6TA5KbFlRlBlZOtY4+Z02YfS0v39jdsWXeUdnZ1fGeU3/E724m+4NLao6mvSBBk5NRm5ZmMVo3h1h+rtGe12nGw+zsHuMdmtd5T//Inai+/5uvAjDwdTjNIf/y34QIIYSKHdWIScsUsgc+OQvUlydm2QrMXxBF5pmASVBaL2PulkGjOicRteYmQtCGj7CZbd9K9lYMzSleqomoGn7UkotQQTTVw6V6Yvq6yipPZofrW4qivUGjG6xT26njjKbomzVfqxBf/0Bv4dv8a1FApGkIBZjKDlTojLLZ/LpfiSoPK3KXKNMwq+Y4uOty4Bv6VvLwnovz+HjtSmFXrhv/8AwW3I02RPHI8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"030\"\n        title=\"\"\n        src=\"/static/2a2e843ffd03a9f74d165136510bd3eb/5a190/030-explicit-architecture-svg.png\"\n        srcset=\"/static/2a2e843ffd03a9f74d165136510bd3eb/772e8/030-explicit-architecture-svg.png 200w,\n/static/2a2e843ffd03a9f74d165136510bd3eb/e17e5/030-explicit-architecture-svg.png 400w,\n/static/2a2e843ffd03a9f74d165136510bd3eb/5a190/030-explicit-architecture-svg.png 800w,\n/static/2a2e843ffd03a9f74d165136510bd3eb/c1b63/030-explicit-architecture-svg.png 1200w,\n/static/2a2e843ffd03a9f74d165136510bd3eb/29007/030-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>좀 더 명확하게 설명하면, 기본 어댑터는 보통 컨트롤러(Controllers) 또는 콘솔 명령(Console Commands)이며, 이들의 생성자(constructor)에는 필요한 인터페이스(포트)를 구현한 객체가 주입(inject)됩니다.</p>\n<p>더 구체적인 예시를 들어보겠습니다.\n• 포트는 컨트롤러가 필요로 하는 서비스(Service) 인터페이스나 리포지토리(Repository) 인터페이스일 수 있습니다. 그러면 컨트롤러에는 이 서비스나 리포지토리를 구현한 구체적인 클래스가 주입되고, 이를 사용하여 비즈니스 로직을 호출하게 됩니다.\n• 또 다른 예로, 포트가 커맨드 버스(Command Bus)나 쿼리 버스(Query Bus) 인터페이스일 수 있습니다. 이 경우 컨트롤러에는 커맨드 버스나 쿼리 버스의 구체적인 구현체가 주입되고, 컨트롤러는 적절한 커맨드나 쿼리를 생성하여 해당 버스에 전달합니다.</p>\n<h3 id=\"보조-어댑터secondary-또는-driven-adapters\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%EC%A1%B0-%EC%96%B4%EB%8C%91%ED%84%B0secondary-%EB%98%90%EB%8A%94-driven-adapters\" aria-label=\"보조 어댑터secondary 또는 driven adapters permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보조 어댑터(Secondary 또는 Driven Adapters)</h3>\n<p>기본 어댑터가 포트를 감싸는 형태인 것과 달리, 보조 어댑터(주도되는 어댑터)는 포트(인터페이스)를 직접 구현한 다음, 이 포트가 필요한 위치(타입 힌트로 지정된)에 주입됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/616fa30ae8335592b918a6e0657dd2f6/29007/040-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAADWElEQVR42l2TW1MaWRhF+bfzI2YeUqnKPGVMjDExUUOJd41RyoyKEkGFhm6abrChG+Sm3G8qYINRI2sO5G0edp23Vfvbex+HWpAIZ0+Qc2dIGT+Jmk66lSDdTlDopii34zRudfoXbp6S6/wyVnjWv/AU+czdyRTXRxO0D19z431Lxz+FI1GJohcVkkKJnIR1qZCt6FxehbiS1mg0NXI5lX7eA8UDmtoKKZ+TWPiY+PcZ0rtvkE8O0N3T5LZf4kiWdayyRqaoclGLkxHOroxDfH/9QejzG4L+GO6lPdp+4UqZo64skPDOYvgWuTz+QPb7azqKC9X7Fc23LRxeaaTyETICajUTVHsW9bSH6Lc1zrwSJe86g9gOA2WdrucjxeUXdDUXtvmVp/QWVXFq63iCvuriVnbh0DJhUpUAEStIri6TN1wUMkeopxodaRW6MvyMC53Dg0FP2aCx8Yqmukg+4OQmPE/teJpHdX6cq8MoRjErEZR0mHxVJqe+5ez0B+n9LbiVGNo6w44CnYiQeH8luT2cof3jHZZ/no66QFZE0A7O8aTOCeCVTrJkkKqblFpxencqWkCmEdqBgcawK0A9dazhCCqc2toW7X//oSgv0tFXsEMz3Ic/8RiZx2GJIszaOclKgmIzhiyF8O2FaCrbYEf/BxQOH+LY6iZ33ndQPeI5s8NPAepHvnAvSnNciM2Nmk2UDUptg03XLuvrIk+vOLkdYDiI/QbejSTgjwlu9t5TO5rk4kxkKLI8PfGz649QDa2KlosaekmMOxUgK0asqUFC4mTtRKZ1tjaG0v2d4bAXxQ4scb8/wXPeTVXMxVadlCNuKso3+rI42RydXNfRCmGshkH5+pxeL0YmF+Po4JTM7jLFmb+pT/7JjfMF5a1X3MWXecjuMsgeUBUN18VPMTWJrLKPI90yyLSSnNciY/BIpabKnuQkrB+SMlOoQZnrgIthbAHb2sL0fqJnbKBbeQ5WpzE2X6KoYi1hjyilHmekpAAZVXUsrRhCMj20bzSqDYl6M8qg4GFgbXOfdtOLr/IYdWIrTuq+99SPpzBjIfKRPRxqIYicPSUm/vKF+CljiaJy1ybZ5jn5xsixJpxti4KXeNBd43k8KLPinR1vrx/8SNc/iR38wH98j7+Ok8R/0AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"040\"\n        title=\"\"\n        src=\"/static/616fa30ae8335592b918a6e0657dd2f6/5a190/040-explicit-architecture-svg.png\"\n        srcset=\"/static/616fa30ae8335592b918a6e0657dd2f6/772e8/040-explicit-architecture-svg.png 200w,\n/static/616fa30ae8335592b918a6e0657dd2f6/e17e5/040-explicit-architecture-svg.png 400w,\n/static/616fa30ae8335592b918a6e0657dd2f6/5a190/040-explicit-architecture-svg.png 800w,\n/static/616fa30ae8335592b918a6e0657dd2f6/c1b63/040-explicit-architecture-svg.png 1200w,\n/static/616fa30ae8335592b918a6e0657dd2f6/29007/040-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>간단한 예를 들어 보겠습니다.</p>\n<p>데이터를 저장하는 간단한 애플리케이션이 있다고 가정해 봅시다. 우리는 데이터를 저장하고 특정 ID로 데이터를 삭제하는 메서드를 갖는 저장 인터페이스(persistence interface)를 먼저 만듭니다. 이후 우리 애플리케이션에서 데이터를 저장하거나 삭제할 때마다 생성자에서 이 저장 인터페이스를 구현한 객체를 필요로 하게 됩니다.</p>\n<p>이제 MySQL 데이터베이스를 사용하는 구체적인 어댑터를 만들어 봅니다. 이 어댑터는 저장 인터페이스를 구현하여 데이터를 실제로 저장하거나 삭제하는 메서드를 제공하고, 애플리케이션 내에서 저장 인터페이스가 필요할 때마다 이 MySQL 어댑터를 주입해 사용합니다.</p>\n<p>나중에 데이터베이스를 PostgreSQL이나 MongoDB로 바꾸고 싶다면, 새로운 데이터베이스에 맞게 저장 인터페이스를 구현한 새로운 어댑터를 만들고 기존 어댑터 대신 새로운 어댑터를 주입하기만 하면 됩니다.</p>\n<h3 id=\"제어의-역전inversion-of-control\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84inversion-of-control\" aria-label=\"제어의 역전inversion of control permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제어의 역전(Inversion of Control)</h3>\n<p>이 패턴에서 주목해야 할 특징은, 어댑터가 특정한 도구와 특정한 포트(인터페이스 구현)에 의존한다는 점입니다. 하지만 비즈니스 로직(애플리케이션 코어)은 오직 자신에게 맞게 설계된 포트(인터페이스)에만 의존할 뿐, 특정한 어댑터나 도구에는 의존하지 않습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dc0357f74d86c76d13b2982e2dfdd57a/29007/050-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAADY0lEQVR42k2UW1MaWRSF+bfzI8anTFWerGh0jInEMILxEo2Wo6MiqBBooOmmG2iuAo3cryIKaJDoN0dqHuZh13n7au291joWtRhAznuRCz4COQ+Jhk62kyDbTVC8y1Dtxmjd6oyuDpgkt/llbPCsf2GirDDwLnLjmqN7NkvPPUffs4glUYuglxWS5TCJQoD0dZh8Tee6FKQU2KLV1iiYEUamk5fSCe3IBplLG9HQBdGjj2QO55C9TvSDJQr7b7AkqzrpqkaurHLViJETykrGGZczvxG0zhHwRtl3HNO+XOVZ+UJLsWO4rRgeB9fnH8j/M0s/bEdx76J59oXCkkbGVMgJaLqdoH6fppl1EtnbxuuSKLm2uFe/05fW6RwuUFib4U5zMEztMsl+p+6ep3PxjpFq51a2Y9FyITI1P0paotCUMQ07Zu6MiE+n7XUwuZFgHJ/OeKBRddto77ylE3Fg+v6iF1ylcbHEk7o6vavFKEdI1RTC2RBmXaagzOPzifvsfeWl5+dlFOWlH4a+AncKz08Jrndn6Z4vkvascquukXdZ6UqfmaifBbCkk6wYZJopKp0YdwMV3S9T8+3CSBMwAbpXpzMFC6W94Cado1kqsoNbfYNhcJnH0CeelFUsaWFEqhEnWUtQbkeRA0E8J0EB/CaAMgzU/wEF/DFGL/CVgXsBGi6ec/v8FKCRMOwxLBReicy9OpuoGlS6Bjv2Q3a2JZLH2yial1E/CsP/oK/vJEl9751gvefKZ6OnOvB6Lzn0KNSFckuirKFXAoQyfvJiZV0NEJFC7DqjWNeP+NXyiduFp/f7eSPTOF1h7JznuXBAQ8RlpNqoKgfUwntiIbFy6nXlpo5WFG63DNGMOFEzjj+qI53/IP/3BqXlt7QWfqe9MkNx6w3D+Abj/CEP+VPqwuGmaEpSC5APn2DJdgxynSTxukK2reNOC8Wmiku2EdDOyCQzqJLMjX8NYkJRZo+k+xP3xje0tMnp5hKJnT+Q1QjpkFOY0ozxOkmh0qirxGsqsWoQKeWk29OotwI02xEeik4e0vs8Zg8YxDYZazaGYRvNyz9pXiySigYxlWMsalESn8MPoqLLV6Ip0xFGFW5S5NtxzJZORfR5KGDj2Dpj3T4N8ThsFTGxTrM3kpa587xnKH3gX+W+vKaZOKyUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"050\"\n        title=\"\"\n        src=\"/static/dc0357f74d86c76d13b2982e2dfdd57a/5a190/050-explicit-architecture-svg.png\"\n        srcset=\"/static/dc0357f74d86c76d13b2982e2dfdd57a/772e8/050-explicit-architecture-svg.png 200w,\n/static/dc0357f74d86c76d13b2982e2dfdd57a/e17e5/050-explicit-architecture-svg.png 400w,\n/static/dc0357f74d86c76d13b2982e2dfdd57a/5a190/050-explicit-architecture-svg.png 800w,\n/static/dc0357f74d86c76d13b2982e2dfdd57a/c1b63/050-explicit-architecture-svg.png 1200w,\n/static/dc0357f74d86c76d13b2982e2dfdd57a/29007/050-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이는 의존성의 방향이 애플리케이션 중심을 향한다는 뜻이며, 아키텍처 레벨에서의 제어의 역전(Inversion of Control, IoC) 원칙을 따르고 있음을 의미합니다.</p>\n<p>다시 한 번 강조하지만, 포트를 설계할 때는 단순히 도구의 API를 따라 만드는 것이 아니라, 반드시 애플리케이션 코어의 필요에 따라 설계해야 합니다.</p>\n<h2 id=\"애플리케이션-코어의-조직화application-core-organisation\" style=\"position:relative;\"><a href=\"#%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BD%94%EC%96%B4%EC%9D%98-%EC%A1%B0%EC%A7%81%ED%99%94application-core-organisation\" aria-label=\"애플리케이션 코어의 조직화application core organisation permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>애플리케이션 코어의 조직화(Application Core Organisation)</h2>\n<p><a href=\"%22https://herbertograca.com/2017/09/21/onion-architecture/%22\">어니언 아키텍처(Onion Architecture)</a>는 DDD(도메인 주도 설계)의 계층 구조를 <a href=\"%22https://herbertograca.com/2017/09/14/ports-adapters-architecture/%22\">포트 &#x26; 어댑터 아키텍처</a>와 결합하여 사용합니다. 이 계층들은 비즈니스 로직, 즉 포트 &#x26; 어댑터 아키텍처의 내부(“헥사곤”)에 좀 더 명확한 구조를 제공하기 위한 것이며, 포트 &#x26; 어댑터 아키텍처와 마찬가지로 모든 의존성의 방향은 내부 중심을 향합니다.</p>\n<h3 id=\"애플리케이션-계층application-layer\" style=\"position:relative;\"><a href=\"#%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EA%B3%84%EC%B8%B5application-layer\" aria-label=\"애플리케이션 계층application layer permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>애플리케이션 계층(Application Layer)</h3>\n<p>유스케이스(use case)는 우리 애플리케이션에서 하나 이상의 사용자 인터페이스(UI)에 의해 애플리케이션 코어 내에서 호출될 수 있는 프로세스를 의미합니다. 예를 들어 CMS 애플리케이션이라면, 일반 사용자를 위한 메인 애플리케이션 UI가 있을 수 있고, CMS 관리자를 위한 별도의 UI, CLI 인터페이스, 웹 API가 별개로 존재할 수도 있습니다. 이 각각의 UI(애플리케이션)는 자신만의 특정한 유스케이스를 실행하거나, 여러 UI가 공통으로 사용하는 유스케이스를 실행할 수도 있습니다.</p>\n<p>이러한 유스케이스는 DDD에서 제공하고 어니언 아키텍처에서 채택한 가장 첫 번째 계층인 애플리케이션 계층(Application Layer)에서 정의됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/08de80af7b1599a9ae3981e5bd9921a2/29007/060-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAADdElEQVR42iWTW1MadxjG+bb9Dm1mOsn0ptNMjDWmxhMRMxLUilaNooggLKdddlmX5SAnQVhhwTMoHvDXv+binffumefoUKpR4qUQiXKYaDFI5lSj0MlQ6GaoXuVpdHXaFxr9ozUeTQ9PxgJDbZZHeZKb0Bhnux/o7rzn3P+Ry+AYjkwzhVZPYorLlKPkjpOUmhrHtRg16TttW6VcSdGv+HiubWGnFsjvO0nHA+gbExTWR0iEttHWxil73+EwGxq5hkqxrnB0qlMUzGrGDvtvfiE2OUI0qOF1bWIHpnmSZ2jLLgz/FMb+PMeBz5Q23nOZdKH4l1H3vYJhTSVfkSkK0JydwbrO0Sr4SHk9hHYi1P0ebvT/uE4u0tkULOZ+40qdp5dd5rHwL5aQ2gl8oK+4uEi4cKjFOPlmBDknUW4lqBguKsUdUgcqHcnNoPiD7te3tCd+5SruxgovYHv+ENLnqUScnMdnOA2M86DMvPrqMOopsk2ZZCFOxUpQlj8SPtjDXF+gKO/Qzbu50mexFSd3RzMM7zVqyyKIvb/JBWe4UOYoCQu60jSPyrQArGmYJwb5VpaTjs7VjUJaSlAPeVFDq/RqizAw4SHHoLXJ49mmkLaMvfEXJ4l5LrQFerEJ7uJfeBAeO3IiiOzpIWYzQ91Ok4jGCG7FaRws89T1cd/0MLxU4eaQQWP1J2B8kRv/KFi7DIurDARQX57lLikYHonOvSSbaRicdA2WXOsseSTMLQ+KFuZCgDxYiwwsrwB38zxIY62M0Nod5SgsPFTmOQgFWQ/KWDG3SLmuop2IcucjlIRkTYmiSHGWfWkmv23wZIcZdnbF32bQjXHqm2bg+8iwvIYl6tIT3jbkNZrJFfoJITn7IrmloVZF2m1DLOOQdEUnkk4j7R1QEuHUv/yJ/el37Kk3VL+/FeoXuC+tc1vaxhIJt8RSsmqUUnILR6FjUOyYHFoyBVvDnxOMKwq7CSdRdYe8mUcWIZ1FvvKsz9EvrGD6J7k2FtFyFbbd4xhL70gqoi1xnwilpfNypmBpWAqHTQW9EUPK+uieq1jtKC07xW3Vx23Oy11hjWvdzUPKSS/ppLX/iVZgjGw6RkX+gUOpSiRKB6TFlo/EUl5PBFU+y1KyD6m0NU7EnnsC7F7/xr3meq3HfXJK/KnX7vWlf7gKjtKTPvM/nyO2lH03obkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"060\"\n        title=\"\"\n        src=\"/static/08de80af7b1599a9ae3981e5bd9921a2/5a190/060-explicit-architecture-svg.png\"\n        srcset=\"/static/08de80af7b1599a9ae3981e5bd9921a2/772e8/060-explicit-architecture-svg.png 200w,\n/static/08de80af7b1599a9ae3981e5bd9921a2/e17e5/060-explicit-architecture-svg.png 400w,\n/static/08de80af7b1599a9ae3981e5bd9921a2/5a190/060-explicit-architecture-svg.png 800w,\n/static/08de80af7b1599a9ae3981e5bd9921a2/c1b63/060-explicit-architecture-svg.png 1200w,\n/static/08de80af7b1599a9ae3981e5bd9921a2/29007/060-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이 계층의 주된 요소는 애플리케이션 서비스(Application Services)와 그 인터페이스들이지만, 또한 ORM 인터페이스, 검색엔진 인터페이스, 메시징 인터페이스 등과 같은 포트 &#x26; 어댑터 인터페이스(포트)들도 포함됩니다. 우리가 커맨드 버스나 쿼리 버스를 사용하는 경우, 커맨드와 쿼리를 처리하는 핸들러(Handlers) 역시 바로 이 계층에 위치합니다.</p>\n<p>애플리케이션 서비스나 커맨드 핸들러는 유스케이스, 즉 비즈니스 프로세스를 실행하는 로직을 포함합니다. 일반적으로 이들의 역할은 다음과 같습니다.</p>\n<ol>\n<li>리포지토리(Repository)를 이용해 하나 이상의 엔티티를 찾고,</li>\n<li>이 엔티티들에게 도메인 로직 수행을 지시한 뒤,</li>\n<li>다시 리포지토리를 통해 엔티티를 저장하여 데이터 변경사항을 영속화하는 것입니다.</li>\n</ol>\n<p>커맨드 핸들러는 두 가지 방식으로 사용될 수 있습니다.</p>\n<ol>\n<li>실제 유스케이스를 수행하는 로직을 직접 담을 수도 있고,</li>\n<li>또는 단순히 아키텍처 내에서 유스케이스를 연결해주는 연결 고리(wiring piece)로 사용될 수도 있습니다. 이 경우 커맨드를 받아 애플리케이션 서비스 내의 로직을 실행하는 역할만 합니다.</li>\n</ol>\n<p>어떤 방식을 선택할지는 다음과 같은 상황에 따라 달라질 수 있습니다.</p>\n<ul>\n<li>이미 애플리케이션 서비스가 존재하고, 이후에 커맨드 버스를 추가하는 경우인지?</li>\n<li>커맨드 버스가 임의의 클래스/메서드를 핸들러로 사용할 수 있게 허용하는지, 아니면 특정 클래스를 상속하거나 특정 인터페이스를 구현해야만 하는지에 따라 결정됩니다.</li>\n</ul>\n<p>이 계층은 또한 유스케이스가 완료된 결과로 발생하는 애플리케이션 이벤트(Application Events) 를 실행시키는 역할도 합니다. 이 이벤트는 유스케이스가 발생시킨 부수적 효과(side effect)를 처리하는 로직을 호출하는 데 사용됩니다. 예를 들어 이메일 전송, 제3자 API에 알림 전송, 푸시 알림 전송, 심지어 다른 컴포넌트의 다른 유스케이스 실행 등을 말합니다.</p>\n<h3 id=\"도메인-계층domain-layer\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B3%84%EC%B8%B5domain-layer\" aria-label=\"도메인 계층domain layer permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도메인 계층(Domain Layer)</h3>\n<p>한 단계 더 내부로 들어가면 도메인 계층(Domain Layer)이 존재합니다. 이 계층의 객체들은 도메인 자체에 특화된 데이터와 이 데이터를 조작하는 도메인 로직을 담고 있으며, 애플리케이션 계층에서 이를 호출하는 비즈니스 프로세스와는 독립적입니다. 즉, 도메인 계층의 객체들은 애플리케이션 계층의 존재조차 모른 채 독립적으로 동작합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7620284cd82bf83c08b0eeb1e63c152e/29007/070-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAADjklEQVR42h2TSU8bdxjG/ZUq9RP02HMPPfTYqrf22AtRW1SpkZoSKCELSxxMYiAQCIEEDMYb3sYez4w9XrE9xiteMYvNbn79w+HVe3v0rCa54CeYcyPl9/BnXcQPVTKtOJl2nMJJmko7SqOr0t9f4yaxyK1uZaC+5iY8yZl7nM7OCO3tJxzZRzl2jWOKVyOopRAJcfG8n9RBiFxV5aAYoOhboNFUyBsR+oaNu+ImzYiVtNOMFnQQ3XhJZv0pknsLdW2C/OowpkRFJVVRyJZk9g+jZAWzor6Nc+hnApNP8btUVi2faTqmuQ3P0Ahb0O1T6M45DhzPyW084ThkQbYvozhXBcOiQtoIkxWgqWac2mmKesZGZHUR97aXkn2RM+0jp9IirY1n5GeHOFHm6CWXucl8oCakthwj9GULXcmCSckGSVe9hFM+8nUJQ7dgZLeJeBRaPiuXxhbd+cd0zH9wElmmtveO5uJfQvochtfMUXCGQ8cE1/LMg68mvRQhWQ0TygQxahL58Ch7nl3in6xkI3bayhsqYz+QGf6OvudvBgOd4tK/tHf/I+WaoSvPkhMWtH3T3MjTArCokijrpOtJyq0oJ2cymk+i5PyAJtnoLv9K4aevyf34FZ3x77k72RKslmhu/ENZmqOrWukFXnIRfMW18NiUEkEkD2MkqnFKTQ3JH8C1GaTiXuL22Mm1/3fKr74lP/ENF5u/cNP+Qjf4njP7GNR2GGQ/cimA+uHXXIQEw33Ruftk4xWdcltnybLO0qKPxOYCsrbHcXGFS/cj+tu/cZ2dgusYtZUR6jtj7O8JD+U5PG4X664wtcC8SLmkoJZFudNeckKyKvuRfUGWbRqTbze4bXm567oYdJxcHoU4tE1xaRtlkF+jJurSk81UwmtUQyv0JSE5eS+5rqIURNoNXSwjhmZE8Woavl0PuU/vKL14TGP8Ec3JIQoLf3IWs3KVW+c8t0VNJFwXS0kqfnKhTUyZlk62lSBWC5NpqthTgrEhsyOZ8SvbpBNpwVii433DXXSWfmaFhH2SU/09aspga34CfWmYkCzaErSJUOpR7i8hWOo1mVhVJloJ4EvaaB8p1Bp+6s0I5wUb56lVLjJrnEbnuY6Y6YXM1J3PqDvGSWoBjPAXTHLBh5TzoIkt74ulPJwIKt9JkmvGMBoqZbHnngC7ir7lSrU81OMqNCX+1EP3+r4XnLjG6Pme8z9aHq4NGR0DmgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"070\"\n        title=\"\"\n        src=\"/static/7620284cd82bf83c08b0eeb1e63c152e/5a190/070-explicit-architecture-svg.png\"\n        srcset=\"/static/7620284cd82bf83c08b0eeb1e63c152e/772e8/070-explicit-architecture-svg.png 200w,\n/static/7620284cd82bf83c08b0eeb1e63c152e/e17e5/070-explicit-architecture-svg.png 400w,\n/static/7620284cd82bf83c08b0eeb1e63c152e/5a190/070-explicit-architecture-svg.png 800w,\n/static/7620284cd82bf83c08b0eeb1e63c152e/c1b63/070-explicit-architecture-svg.png 1200w,\n/static/7620284cd82bf83c08b0eeb1e63c152e/29007/070-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4 id=\"도메인-서비스domain-services\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4domain-services\" aria-label=\"도메인 서비스domain services permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도메인 서비스(Domain Services)</h4>\n<p>앞서 언급했듯이, 애플리케이션 서비스의 역할은 보통 다음과 같습니다.</p>\n<ol>\n<li>리포지토리를 통해 엔티티를 찾고,</li>\n<li>엔티티에 도메인 로직을 수행하도록 지시하고,</li>\n<li>다시 리포지토리를 통해 엔티티의 변경사항을 저장합니다.</li>\n</ol>\n<p>하지만 때때로 여러 엔티티(같은 유형이든 다른 유형이든)를 포함하는 도메인 로직이 발생하는 경우, 이 로직이 각 개별 엔티티에 직접적으로 속하지 않는다고 판단될 수 있습니다. 즉, 엔티티가 직접 책임질 필요는 없는 로직이 등장하는 것입니다.</p>\n<p>이때 일반적으로 처음 떠오르는 방법은 애플리케이션 서비스에 이 로직을 위치시키는 것입니다. 그러나 이렇게 하면 이 로직은 다른 유스케이스에서 재사용하기 어려워집니다. 즉, 도메인 로직은 애플리케이션 계층에 있어서는 안 됩니다.</p>\n<p>이 문제를 해결하는 방법은 도메인 서비스(Domain Service) 를 만드는 것입니다. 도메인 서비스는 여러 엔티티를 받아 그 위에서 도메인 로직을 수행하는 역할을 합니다. 도메인 서비스는 도메인 계층에 속하기 때문에 애플리케이션 계층의 클래스들(애플리케이션 서비스나 리포지토리)에 대해 전혀 알지 못합니다. 대신, 도메인 서비스는 다른 도메인 서비스 또는 도메인 모델 객체를 사용할 수 있습니다.</p>\n<h4 id=\"도메인-모델domain-model\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%AA%A8%EB%8D%B8domain-model\" aria-label=\"도메인 모델domain model permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도메인 모델(Domain Model)</h4>\n<p>아키텍처의 가장 중앙, 즉 외부의 어떤 것에도 의존하지 않는 중심부에는 도메인 모델(Domain Model)이 있습니다. 도메인 모델에는 엔티티(Entity)를 포함하여, 값 객체(Value Object), 열거형(Enum), 그리고 도메인을 표현하는 모든 비즈니스 객체가 존재합니다.</p>\n<p>또한, 도메인 모델에는 데이터가 특정 방식으로 변경될 때 발생하는 도메인 이벤트(Domain Events) 가 포함됩니다. 어떤 엔티티의 데이터가 변경될 때마다 도메인 이벤트가 발생하여, 변경된 속성의 새로운 값을 함께 전달합니다. 이는 예를 들어 이벤트 소싱(Event Sourcing)에 사용하기에도 매우 적합합니다.</p>\n<h2 id=\"컴포넌트components\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8components\" aria-label=\"컴포넌트components permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트(Components)</h2>\n<p>지금까지는 코드의 계층(layers)을 기준으로 코드를 나누는 방법을 이야기했습니다. 하지만 이것은 비교적 세부적인 코드 분리 방법입니다. 이와는 별개로, 더 넓은 관점에서 코드를 분리하는 방법이 있으며, 그것은 하위 도메인(sub-domain)이나 <a href=\"%22http://ddd.fed.wiki.org/view/welcome-visitors/view/domain-driven-design/view/bounded-context%22\">바운디드 컨텍스트(bounded context)</a>를 기준으로 나누는 방식입니다. 로버트 C. 마틴(Robert C. Martin)은 이를 두고 <a href=\"%22https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html%22\">소리치는 아키텍처(screaming architecture)</a>라고 표현한 바 있습니다. 이것은 흔히 ‘기능별 패키징(package by feature)’ 또는 ’컴포넌트별 패키징(package by component)’이라고 불리며, 계층별 패키징(package by layer)의 반대 개념입니다. 사이먼 브라운(Simon Brown)의 블로그 포스트 “<a href=\"%22http://www.codingthearchitecture.com/2015/03/08/package_by_component_and_architecturally_aligned_testing.html%22\">Package by component and architecturally-aligned testing</a>” 에서 이 개념을 아주 잘 설명하고 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 362px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/674f7fe2e166ac5869f94af3ac56b717/c2de8/20150308-package-by-layer.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRowAAABXRUJQVlA4IIAAAACQBACdASoUABQAPtFYokuoJSMhsAgBABoJQBbZA9DmLpcfg+w1YjFQGGSj0IAA/sAiycTF82OBF9F02kCpgPFEcsphc0pllnXjNQe2DoNi41gvw6yaNeLsvSJXR/lV9Apis7LxWSnAhrHMCplDeZvoaD6o3S0Iyut+qFbv2YegAA=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20150308-package-by-layer\"\n        title=\"\"\n        src=\"/static/674f7fe2e166ac5869f94af3ac56b717/c2de8/20150308-package-by-layer.webp\"\n        srcset=\"/static/674f7fe2e166ac5869f94af3ac56b717/ba381/20150308-package-by-layer.webp 200w,\n/static/674f7fe2e166ac5869f94af3ac56b717/c2de8/20150308-package-by-layer.webp 362w\"\n        sizes=\"(max-width: 362px) 100vw, 362px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 362px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/badac565253bd30d8abd5808a92a2767/c2de8/20150308-package-by-feature.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRogAAABXRUJQVlA4IHwAAAAQBACdASoUABQAPslQoUunpKMhsAwA8BkJQBfnA1suYakW3TRNWrZLAAD+wClDrwWeb241RcV9yfphq3Mo8qJxzSqKhzD8KCYiqVojQSUhx2DF8CRMVFzIzxm+aBgobcf3RUIcBRmmTR5lBBOzql4aUMbZrhaTNVHAEAAA'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20150308-package-by-feature\"\n        title=\"\"\n        src=\"/static/badac565253bd30d8abd5808a92a2767/c2de8/20150308-package-by-feature.webp\"\n        srcset=\"/static/badac565253bd30d8abd5808a92a2767/ba381/20150308-package-by-feature.webp 200w,\n/static/badac565253bd30d8abd5808a92a2767/c2de8/20150308-package-by-feature.webp 362w\"\n        sizes=\"(max-width: 362px) 100vw, 362px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 362px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/056d16b7224c5fb00bf560434d6924af/c2de8/20150308-package-by-component.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRooAAABXRUJQVlA4IH4AAADQAwCdASoUABQAPsVOokunpCMhsAwA8BiJQBbZA2yAhoGIKyWyg4AA/sApQ69wkr8fDcsxhLxjZhjtn9D0Yvz5KjykjhIxAMRpefl8pDjsGL4EibqPP7MR39n7tki3S8VVwxBToqENX/z4tDDzSfkPFPORZp5Nm+rtmvItzgA='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20150308-package-by-component\"\n        title=\"\"\n        src=\"/static/056d16b7224c5fb00bf560434d6924af/c2de8/20150308-package-by-component.webp\"\n        srcset=\"/static/056d16b7224c5fb00bf560434d6924af/ba381/20150308-package-by-component.webp 200w,\n/static/056d16b7224c5fb00bf560434d6924af/c2de8/20150308-package-by-component.webp 362w\"\n        sizes=\"(max-width: 362px) 100vw, 362px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>저는 개인적으로 “컴포넌트별 패키징(package by component)” 방식을 선호하며, 사이먼 브라운의 다이어그램을 빌려 제 방식대로 수정하여 다음과 같이 표현합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b961aff487e224a03189161ac747942c/d7abb/Packaging_4_3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC9ElEQVR42jVTaZOiSBD1x3WHfYwKniCHxSWeDQpyCQIqCGirjWPrHBGz+2G/dM+P3DRmtyIrIquiMvLVey8L9/f3xWIRoc5oPFIUZaLelqZphmlasGxLEAXUYVmGptpkq9mo16qVSvnx8fHu7q7w8PBQLpdJVlRVeOnbVmAa3nDiWKbv2KFjBRPVEscmP5yhvo4GOi2pTYIulb5AYeHp6alarxMEF4XH4PrpXz+X2x+e6q7Sa3D5CK6/N9FJMTdadDbjsxGfBT1u0QKOVZ6fnwulUqnebDCsfFStfJEe/SzX5qFi57oLOQSUqkZkJpfl4edi912cxRTqAnjAW4BNEK0aJU1pKURdn++5tCD1LYuRAr4XcLLNSJ2Ry74skOIj1W91DYIR4POVSqWAYRjZbpO05NrxPL3ayWURHnR1vgheneTiJFffS3vaUtAjQVtJs5geeUAQ9MMwvIDjOElRqCPH4cG7/J6/fyyz7+vpfJV98y6fzvljs85VM+KNRDI2XTNBkyXDyyTRwqvVQrVabVMUi/o7xXr1ku0iO2iuqzj72WJ3O6Z7xZy5GVClr9709alvJTQnt0kSCm+dATUjvGRIPtPo1BFyGoW96ZHhTiz3leUODD+yk6G7GzjZcL4VtDUU/9cZ/kyQZIcbRFMvDXbp6hDr/rkjrp3NdrmP/ddEW4zNWDRTwCxbKcCmuS7RamI4/j/bbVEZGJbqQMxerOlgpo8sS7GNsaWPLTT2qKFLDefM2GuIeoviWs3mjW3QudloNNHA27wn+d+rw68g+zaPTtn7P8fscsj/it9+yUY8DQ8QWnjkJkuQql6vlUBncFitWm3x49X6bZ+cs805Xuf+6rjfXvPlLk++Ztl7387AXuAQEBI0Ixgex7Gbw4rFBwyrNFi5Pwk0PdBm4YsWyvpSmfoTLZho/kgLQGHZiAZAm5MC8ma7U/7jbRgOGJFavUFQLMVyLC8isStIsiD3xd4AAhJBlBHc82KHExiWq9Xqf6bqX9X3hF0n4ZB0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Packaging_4_3\"\n        title=\"\"\n        src=\"/static/b961aff487e224a03189161ac747942c/5a190/Packaging_4_3.png\"\n        srcset=\"/static/b961aff487e224a03189161ac747942c/772e8/Packaging_4_3.png 200w,\n/static/b961aff487e224a03189161ac747942c/e17e5/Packaging_4_3.png 400w,\n/static/b961aff487e224a03189161ac747942c/5a190/Packaging_4_3.png 800w,\n/static/b961aff487e224a03189161ac747942c/d7abb/Packaging_4_3.png 959w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이러한 <a href=\"%22https://herbertograca.com/2017/07/05/software-architecture-premises/%22\">컴포넌트</a>는 앞서 설명한 계층(layer)을 가로지르는 구조를 갖습니다. 즉, 각 컴포넌트는 도메인과 밀접히 관련되어 있으며, 예시로는 인증(Authentication), 권한부여(Authorization), 결제(Billing), 사용자(User), 리뷰(Review), 계정(Account)과 같은 것이 있습니다. 특히 권한부여나 인증과 같은 바운디드 컨텍스트는 외부 도구로 보고 이를 어댑터로 감싸 포트를 통해 접근하게 만듭니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b41db7a04248d63fb518c708fca6cb94/29007/080-explicit-architecture-svg.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABcSAAAXEgFnn9JSAAADiklEQVR42h2TSVdadxjG+Ur9At113w/QXRbt6ab9AKbtsT3toh7jEC1RCRUNDliN0agoMsl8L/eCl1HgKqNMYlTQINFf/7p4z7t7zjMa5NMAobyHcOGIQM5N4lwl20qQbSc4vcpQacdpXKr0TjYZJFf4oll5UN8ykGa48UxycTBKe3+EjmOMT+5JDIlqFLUUISkuUQiQPouQr6qcFYMU/cs0mgoFPUpPt/NY3KUZtZJxmYmFnMS3jWS3XhH27KFuTlHYGMaQrKikKwq5kszJeZycYFbU9nENfU9w5hUBt8qG5SNN5xxfJBMNyYLmmEVzLXDmnCa/PcKniAXZsYbi2hAMiwoZXSInQNPNBLXrNPWsnej6Cp59HyXHCtfqe65Cy7S2X1OYH+JKWaCbWmOQ/Y+akNpyjtKTLVyGLRiUXIhM1YeU9lOoh9E1C3pun+iRQstn5Ta3Q8f6Jy3Tb3QkGxXvIs2VP4T0BXSfmU7IxLlzinvZ9OyrQStFSVUlItkQei1MQRrjyHtI4sM7TuQDWoqZyvh35Ia/5c7zO48PMYq2EdqHE6TdJi7lefLCgrZ/joE8JwCLKsmyRqaeotyKc3UjE/OHKbrWUEO7dNZ+ovDiK9QXX1OY+IHr1iENn03I/5tSeIFL1Uo3aOQu9IZ74bEhLYJInR+TrCYoNWOEA0HcuyHKnlXuO076/l8pT3+D2/gjv5hivDCWSOys8tk1zmPtgIfcez4LoJ70lruIYHgiOveUbKKiUW5r2Cxb2Fb8JHeWkVQvl2fr3LpfMjj4mar6jp1YhZJtlIZjnKxXeCgv4PW42XJL1IJLIuWSgloW5c74yAvJqhxA9odYs8eYWdxmUD/i4cLFfcspGAdFgY307WM8FDapibp0ZeGxtEk1sk4vLCSnniTXVZRTkXZDE8s4JqbH8cVi+A+95D9YKRr/ojHxksabIfSlYW7iVvr5LW7ze9REwnWxlJQSIB/ZxZBtaeRaSY5rEtmmiiMtGOsyB2EzAWWfTDIjGIe58P0L8Xl6mXWSjhmutVXUtM7e0hSabZiILNoSsotQ6nGeLilYajWZ46pMvBLEn7LT7ijUGgHqzSi3p3Zu0xvcZTe5ji9xHzXTjZipu15Td06SigXRpR0M8qmfcN5LTGz5RCzl+URQhYsU+eYxekOlLPbcFWD9+CJ91fJcj35kVvzZ5+71/P9w5R6n65/mf0TzrAtZm4M6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"080\"\n        title=\"\"\n        src=\"/static/b41db7a04248d63fb518c708fca6cb94/5a190/080-explicit-architecture-svg.png\"\n        srcset=\"/static/b41db7a04248d63fb518c708fca6cb94/772e8/080-explicit-architecture-svg.png 200w,\n/static/b41db7a04248d63fb518c708fca6cb94/e17e5/080-explicit-architecture-svg.png 400w,\n/static/b41db7a04248d63fb518c708fca6cb94/5a190/080-explicit-architecture-svg.png 800w,\n/static/b41db7a04248d63fb518c708fca6cb94/c1b63/080-explicit-architecture-svg.png 1200w,\n/static/b41db7a04248d63fb518c708fca6cb94/29007/080-explicit-architecture-svg.png 1600w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"컴포넌트-간의-결합도-낮추기decoupling-the-components\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B0%84%EC%9D%98-%EA%B2%B0%ED%95%A9%EB%8F%84-%EB%82%AE%EC%B6%94%EA%B8%B0decoupling-the-components\" aria-label=\"컴포넌트 간의 결합도 낮추기decoupling the components permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 간의 결합도 낮추기(Decoupling the components)</h3>\n<p>미세한 코드 단위(클래스, 인터페이스, 트레잇, 믹스인 등)뿐 아니라, 컴포넌트와 같은 좀 더 거시적인 코드 단위도 결합도는 낮고 응집도는 높은 상태가 이상적입니다.</p>\n<p>클래스 간 결합도를 낮추기 위해 우리는 의존성 주입(Dependency Injection) 을 사용하여 클래스 내부에서 직접 의존성을 생성하는 대신, 외부로부터 의존성을 주입받습니다. 또한 의존성 역전 원칙(Dependency Inversion) 을 사용하여 구체적인 클래스 대신 추상화(인터페이스나 추상 클래스)에 의존하도록 만듭니다. 이렇게 하면 의존성을 가진 클래스는 사용하는 구체적인 클래스에 대해 알지 못하며, 의존하는 클래스의 정확한 이름조차도 알 필요가 없습니다.</p>\n<p>마찬가지로, 완전히 결합도가 낮은 컴포넌트는 다른 컴포넌트에 대해 직접적인 지식(심지어 인터페이스조차도)이 없습니다. 이는 단지 의존성 주입이나 의존성 역전 원칙만으로는 부족하며, 별도의 아키텍처적 구조가 필요하다는 의미입니다. 우리는 이를 위해 이벤트(Event), 공유 커널(Shared Kernel), 최종 일관성(Eventual Consistency), 또는 서비스 디스커버리(Discovery Service) 같은 추가적인 구조를 필요로 할 수 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e087b7b28e9da1becb829e7c61cc952f/1b1d5/100-explicit-architecture.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAADVUlEQVR42hWTWW8adxTF5zP1E/S1T33qUz9AXyq1UqtWSaWmfaiitsH1ksU2m8GB2mAbEhMgYRsGmH3f/sMMGAaYwTO2wSw2iJiqE+k+nJere49+50CsiWE6jBtVVK+Ifao9AqTeOM7GTouJbP1NLf4HdfgrHXtyXdl5YII3pU0n/+ymuHGZ+3uMvII0R9QcQXUE4AjNK0lzJWOs9WdNdyLe3okr691/ndQaJD5ykRkeXJLBBRGYYMEFvr+kQlDTFWWLa1q8btKaSbct1uCzrfSO2WMZhm7lUjf4G5uNcoUQVq9w6U0p85xCYepsc1DYhtgWoRio3iG1IW+M1D4owb98U42E0QJeSWVF/wuwvakmwjoS6mKR64bfKW/NiSBVTun4OaRYHLgUdIvTLkV7JNzYMI9U6TJ82zhaoLF7LD4qB7iNx/rr0Byk79SEmd9wS/+sufCSOYAwuab2YEqpqSbaV/2qkOZgzKnF7syCG3k0fPndJRId4qedwFMmttejIjMqZCOhezKwYsJQXaoIXUo02dYl77TjJAaDXIKGM3bxWf/3L42fv7iOfyu+jXeTPjmwzb/fnTDRi8LuFNtbsQcQbeCiyau2Yl4LzhUvCXI7GwNMdp75wfj+M/WnzwdHP1pcckwk9V3fSEytQOKBeLmmdj9dFvu051m15P5YLGQq52nUrCTW09qC8znRr3qvv75i9ucTaph/AQLby1Z2qRx36/+26sk5HYWMa0VzBcFkL1ypXCieHSFkpRxJvR9d1dfdyArsrccf1lfo8PBP7Tgsl145ZLxYI+o1eEpGIAI02B6Ggapis50+o6jEGQLSpx8W/MmCPblnkrd0wvA/GcTCCzXzoB/dEftTMurQZzM6Bik213RlyaJ1VxIHAmGItFqsIGU2W+L3d9tPH/d8v/HhvVbp4P7inSaRzMlfzexWg5EG9Pmnt72Rh4w8pKoGyXQaOeKw1YMtV2n2NJvITdm3U5Du4eGFlAQMwqd8ev45ysqWt8z3CHFAyzarDL2ccJ4QumS7Txhd2HawZfd8CY4/guSECDvlnXF1y2vIFA9a5OmUjkNMB4WlfA0UvW4RLUQaMMAWuQ4ldmkv8HMp4fH0qMwwv4vsj9DAjAit6KBHa0WH/ge2ycAIQUPZdQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"100\"\n        title=\"\"\n        src=\"/static/e087b7b28e9da1becb829e7c61cc952f/5a190/100-explicit-architecture.png\"\n        srcset=\"/static/e087b7b28e9da1becb829e7c61cc952f/772e8/100-explicit-architecture.png 200w,\n/static/e087b7b28e9da1becb829e7c61cc952f/e17e5/100-explicit-architecture.png 400w,\n/static/e087b7b28e9da1becb829e7c61cc952f/5a190/100-explicit-architecture.png 800w,\n/static/e087b7b28e9da1becb829e7c61cc952f/1b1d5/100-explicit-architecture.png 876w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h4 id=\"다른-컴포넌트의-로직을-실행하기triggering-logic-in-other-components\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%A5%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EB%A1%9C%EC%A7%81%EC%9D%84-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0triggering-logic-in-other-components\" aria-label=\"다른 컴포넌트의 로직을 실행하기triggering logic in other components permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다른 컴포넌트의 로직을 실행하기(Triggering logic in other components)</h4>\n<p>한 컴포넌트(컴포넌트 B)에서 다른 컴포넌트(컴포넌트 A)에 어떤 일이 발생했을 때 특정 작업을 수행하고자 한다면, A에서 직접적으로 B의 클래스나 메서드를 호출할 수는 없습니다. 그렇게 하면 A가 B에 직접 의존하게 되기 때문입니다.</p>\n<p>대신 A는 이벤트 디스패처(Event Dispatcher)를 사용하여 애플리케이션 이벤트를 발행(dispatch)하고, 이 이벤트를 듣고 있는 모든 컴포넌트(B 포함)는 해당 이벤트를 받아 원하는 작업을 수행합니다. 이렇게 하면 컴포넌트 A는 이벤트 디스패처에 의존하게 되지만, 컴포넌트 B와의 결합도는 낮출 수 있습니다.</p>\n<p>하지만 이벤트 자체가 컴포넌트 A에 정의되어 있다면, B는 여전히 A의 존재에 대해 알게 되고, 여전히 A에 결합된 상태입니다. 이러한 의존성을 제거하기 위해 우리는 모든 컴포넌트가 공유하는 핵심적인 기능을 포함하는 별도의 라이브러리인 <a href=\"%22http://ddd.fed.wiki.org/view/welcome-visitors/view/domain-driven-design/view/shared-kernel%22\">공유 커널(Shared Kernel)</a> 을 만들 수 있습니다. 그러면 컴포넌트들은 공유 커널에만 의존하게 되며 서로 간에는 결합되지 않습니다. 공유 커널은 애플리케이션 이벤트, 도메인 이벤트뿐 아니라 스펙(Specification) 객체 등 공유가 의미 있는 요소를 담고 있습니다. 하지만 공유 커널이 변경되면 모든 컴포넌트에 영향을 주기 때문에 가능한 한 최소화하는 것이 좋습니다. 또한 다양한 프로그래밍 언어를 사용하는 폴리글랏 시스템(마이크로서비스 등)에서는, 공유 커널이 언어 중립적(JSON 등)이어야 하며, 각 컴포넌트는 이 중립적 정의를 기반으로 구체적 구현을 자동 생성할 수도 있습니다. (<a href=\"%22https://herbertograca.com/2018/07/07/more-than-concentric-layers/%22\">More then concentric layers</a>)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4c486197ead0a3876b911e49627b8776/7e881/explicti_arch_layers.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAACR0lEQVR42nWS2W+bQBDG/f+rr5X60NcqUtT0IWmTSEnjxDg1xuBgg7ELXg7DcizmWBPMDV2nR1Ql+TTSjrQzO59+O722a7sntW2b5XsvtmFg5FXe/VPbdm+od7htmjRPzK0BkKQ6M9WVFPDgIKNo9s+drz3Rw/sYxoaCJMVbLcAKyJMNf+ncHqmDc5u9inU6RUZTV6Q0z/OiKMonkYxED7rWUhN/2gvZnU/YKWSvEfWRPfnk3h5b1InPfwmYI5c7TTzN97dEURxjHAfbre/7B9tpkm4sU9ZFF/zAk7OIv7DZC5s7j8XTXPgMmG9LnsYhesV2GIZZlpGsLGtbB+v+B+/uHbx5v6aOIX+FNJFeQhgVpAAhHyGUJAnJm6YhgHvEO7QtWVuhCJV5hhXGEi4Be6nKQoh3pM6OMtXydjiqqqqua9L2PBnF3iZUZVeaKgwvc5YP87IgfMq2xWkGNvYNt1ZM1LX1gdOzisNk1yWsZrItqpEsufPRcjyczVeaKSjGcLaeqYiSYwZE23iHd9h/ghaGEQliobcvWs3DkxU/WgwmsiCY0dyM6dVmLEPBwhIMvrIKK+mPj+nLj+6ppjMD7tJJJTvggHwvMJQocJo7NdzhUhQV+poba5bS1TiMYs9zCbbftA7NdVWFQbDWNiJwwEJxmIHM9kcPFMcNLGnY7edn9PTkjisSVDcE8v/A/ixf0yQ7bAFFn9AO1fdHfX/4Hd7fGYsH3YL4MXt7t//uLTnSorChteZYXRT8rV9U9cuesqoI+aqqfgEwBv9M/KPfIAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"explicti_arch_layers\"\n        title=\"\"\n        src=\"/static/4c486197ead0a3876b911e49627b8776/5a190/explicti_arch_layers.png\"\n        srcset=\"/static/4c486197ead0a3876b911e49627b8776/772e8/explicti_arch_layers.png 200w,\n/static/4c486197ead0a3876b911e49627b8776/e17e5/explicti_arch_layers.png 400w,\n/static/4c486197ead0a3876b911e49627b8776/5a190/explicti_arch_layers.png 800w,\n/static/4c486197ead0a3876b911e49627b8776/c1b63/explicti_arch_layers.png 1200w,\n/static/4c486197ead0a3876b911e49627b8776/7e881/explicti_arch_layers.png 1521w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이러한 접근은 모놀리식(monolithic) 애플리케이션과 마이크로서비스 같은 분산 시스템 모두에서 효과적입니다. 하지만 이벤트 전달이 비동기적(asynchronous)으로만 가능할 때, 즉 다른 컴포넌트의 로직을 즉시 실행해야 할 때는 충분하지 않습니다. 이럴 때 컴포넌트 A는 컴포넌트 B에 직접적인 HTTP 요청을 보내야 하며, 이때는 컴포넌트 간 결합도를 낮추기 위해 서비스 디스커버리(discovery service)를 통해 대상 컴포넌트의 위치를 찾거나, 서비스 디스커버리가 요청을 중계(proxy)하여 최종 응답을 반환하도록 할 수 있습니다.</p>\n<h4 id=\"다른-컴포넌트의-데이터-얻기getting-data-from-other-components\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EB%A5%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%96%BB%EA%B8%B0getting-data-from-other-components\" aria-label=\"다른 컴포넌트의 데이터 얻기getting data from other components permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다른 컴포넌트의 데이터 얻기(Getting data from other components)</h4>\n<p>컴포넌트가 자신이 소유하지 않은 데이터를 직접 변경하는 것은 허용되지 않습니다. 그러나 자신이 소유하지 않은 데이터를 조회하여 사용하는 것은 허용될 수 있습니다.</p>\n<h5>공유된 데이터 저장소(Data storage shared between components)</h5>\n<p>한 컴포넌트(예: Billing)가 다른 컴포넌트(예: Account)의 데이터를 사용할 필요가 있다면, Billing 컴포넌트는 쿼리 객체(Query object)를 이용해 데이터를 저장소로부터 조회합니다. 이 방식에서 Billing 컴포넌트는 모든 데이터셋의 존재에 대해 알 수 있지만, 자신이 소유하지 않은 데이터를 읽기 전용(read-only)으로만 사용할 수 있습니다.</p>\n<h5>컴포넌트별로 분리된 데이터 저장소(Data storage segregated per component)</h5>\n<p>이 경우 동일한 원칙이 적용되지만, 데이터 저장소 수준에서의 복잡성이 증가합니다. 각 컴포넌트가 독자적인 데이터 저장소를 가지며, 저장소에는 다음이 존재합니다.</p>\n<ul>\n<li>자신이 소유하고 있으며 변경할 수 있는 데이터(단일 진실의 원천, single source of truth)</li>\n<li>다른 컴포넌트가 소유한 데이터의 복사본이며 변경할 수 없지만 컴포넌트 기능에 필요한 데이터(소유한 컴포넌트가 변경할 때마다 업데이트)</li>\n</ul>\n<p>각 컴포넌트는 필요한 데이터의 로컬 복사본을 가지고 사용하며, 데이터의 소유 컴포넌트가 변경이 발생할 때마다 도메인 이벤트를 발행하면, 이를 듣고 있던 컴포넌트들이 해당 복사본을 즉시 업데이트합니다.</p>\n<h2 id=\"제어-흐름flow-of-control\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EC%96%B4-%ED%9D%90%EB%A6%84flow-of-control\" aria-label=\"제어 흐름flow of control permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제어 흐름(Flow of control)</h2>\n<p>앞서 말했듯이, 제어 흐름은 기본적으로 사용자에서 출발해 애플리케이션 코어로 이동한 뒤, 인프라스트럭처 도구를 거쳐 다시 애플리케이션 코어로 돌아오고, 최종적으로 사용자에게 응답을 전달합니다. 그런데 구체적으로 클래스는 어떻게 연결되는 걸까요? 어떤 클래스가 어떤 클래스에 의존해야 할까요? 클래스들을 어떻게 구성해야 할까요?</p>\n<p>이 질문에 답하기 위해, Uncle Bob이 클린 아키텍처(Clean Architecture) 글에서 사용한 방식을 참고하여, 다음 UML 스타일의 다이어그램으로 제어 흐름을 설명하겠습니다.</p>\n<h3 id=\"커맨드쿼리-버스를-사용하지-않을-때without-a-commandquery-bus\" style=\"position:relative;\"><a href=\"#%EC%BB%A4%EB%A7%A8%EB%93%9C%EC%BF%BC%EB%A6%AC-%EB%B2%84%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8Cwithout-a-commandquery-bus\" aria-label=\"커맨드쿼리 버스를 사용하지 않을 때without a commandquery bus permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>커맨드/쿼리 버스를 사용하지 않을 때(Without a Command/Query Bus)</h3>\n<p>커맨드 버스를 사용하지 않을 경우, 컨트롤러(Controller)는 애플리케이션 서비스(Application Service) 또는 쿼리 객체(Query object)에 의존하게 됩니다.</p>\n<p>[2017-11-18 수정]\n처음에는 쿼리 결과를 전달하는 데 사용하는 DTO를 빠트렸었는데, 이를 <a href=\"%22https://www.reddit.com/user/MorphineAdministered%22\">MorphineAdministered</a>가 <a href=\"%22https://www.reddit.com/r/PHP/comments/7dcz8k/ddd_hexagonal_onion_clean_cqrs_how_i_put_it_all/dpy6va4/%22\">지적</a>해 주어 추가하였습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7a5e4be33af31b5cb148a60bbd71752c/5a6dd/4_3_UMLish_1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB40lEQVR42o1TyW7bMBDVH/fer+mt5xyC2kXQQ5ukQF00XlrEDhRvslYuIkWLorgpIxkImqB1+w5DguDjzHszDLqX8AOstcYYiP4sgu4P8HQ/f7z7WMb33Vm8JjPGKKWM4iJLKEGsB2VlyaujaIyQbTVseN3ySgSnUp/JhBClFBRMi3C7uq15alxnfCdpnE7HaHUrcEwWYzwfZdH6dWbOuXOuf9GZVknnfLr5emR7LUj84xItv6hjeffuzfz9W0ZRcPIGbjsPLAc1C5YdWWKNMlriZBGHnxg5tNr4oUgIWTjLNr9ELYMkicMwhKPd7j46PBRFXqItSlZaHXVTZuvPNJ1XNCLbKx5fO6v6NM5q3YIZAcYYAfB+s503ShKCBQ4lWSpZqtZI+lOk15LM8vCSbEfWyJ5sDZBBYKBhbVvvXYF26/UsR6jiYX640m0DKnRDOd5U9FCLXCvmT3Z4D0p78rNVDtR3Pp1O84sLMh7pRsENbRwjUXZYNLI0ttMDIFld1+BO8PtwQaiiqLi5IZMJtJtxDsL2q+/33z6kuyWhJYiCXoJSiMAPun9BckSSR6vEMAz+3IT1I+v6rg1rr5BWcrJKmlbPHvbGusHtHn+b7RdQSue0AkMwq4EBz5+U/xf5zMd4AscKWrXXPiVAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4_3_UMLish_1\"\n        title=\"\"\n        src=\"/static/7a5e4be33af31b5cb148a60bbd71752c/5a190/4_3_UMLish_1.png\"\n        srcset=\"/static/7a5e4be33af31b5cb148a60bbd71752c/772e8/4_3_UMLish_1.png 200w,\n/static/7a5e4be33af31b5cb148a60bbd71752c/e17e5/4_3_UMLish_1.png 400w,\n/static/7a5e4be33af31b5cb148a60bbd71752c/5a190/4_3_UMLish_1.png 800w,\n/static/7a5e4be33af31b5cb148a60bbd71752c/5a6dd/4_3_UMLish_1.png 802w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>위의 다이어그램에서 애플리케이션 서비스에 인터페이스를 사용하고 있지만, 사실 애플리케이션 서비스가 애플리케이션 코드 내부에 존재하며 다른 구현체로 바꿀 가능성이 거의 없기 때문에 인터페이스가 반드시 필요하다고 보기는 어렵습니다. 물론 전체를 리팩토링하는 경우에는 필요할 수 있습니다.</p>\n<p>쿼리 객체(Query object) 는 사용자에게 데이터를 보여주기 위해 최적화된 조회 로직만을 담고 있으며, 조회된 데이터는 DTO를 통해 반환되고 이를 뷰 모델(ViewModel)에 주입합니다. 뷰 모델은 화면에 표시할 데이터를 가공하는 로직을 포함할 수도 있고, 이를 통해 최종적으로 뷰(View)를 구성합니다.</p>\n<p>반면, 애플리케이션 서비스(Application Service) 는 데이터를 단순히 조회하는 것 이상으로, 시스템에서 어떤 작업을 수행할 때 호출하는 유스케이스 로직을 담고 있습니다. 애플리케이션 서비스는 필요한 로직을 수행하는 엔티티(Entity)를 제공하는 리포지토리(Repository)에 의존합니다. 여러 엔티티가 관여하는 복잡한 도메인 프로세스를 조율할 때 도메인 서비스(Domain Service)를 사용할 수도 있지만, 실제로는 흔한 일은 아닙니다.</p>\n<p>애플리케이션 서비스는 유스케이스 로직을 완료한 후, 이를 시스템에 알리기 위해 이벤트 디스패처(Event Dispatcher)를 통해 애플리케이션 이벤트를 발생시킬 수 있습니다.</p>\n<p>여기서 흥미로운 점은 지속성 엔진(Persistence Engine, ORM 등)과 리포지토리에 각각 인터페이스를 두고 있다는 것입니다. 언뜻 보면 중복되어 보이지만, 이들은 목적이 서로 다릅니다.</p>\n<ul>\n<li>지속성 인터페이스 는 ORM 위에 추상화된 계층을 제공하여, 사용하는 ORM을 바꾸더라도 애플리케이션 코어를 변경할 필요가 없게 합니다.</li>\n<li>리포지토리 인터페이스 는 지속성 엔진 자체를 추상화합니다. 예를 들어 MySQL에서 MongoDB로 전환할 때, 지속성 인터페이스는 그대로 두고 같은 ORM을 계속 사용할 수도 있지만, 쿼리 언어 자체가 SQL과 완전히 다르기 때문에 새로운 리포지토리를 만들어야 합니다.</li>\n</ul>\n<h3 id=\"커맨드쿼리-버스를-사용할-때with-a-commandquery-bus\" style=\"position:relative;\"><a href=\"#%EC%BB%A4%EB%A7%A8%EB%93%9C%EC%BF%BC%EB%A6%AC-%EB%B2%84%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8Cwith-a-commandquery-bus\" aria-label=\"커맨드쿼리 버스를 사용할 때with a commandquery bus permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>커맨드/쿼리 버스를 사용할 때(With a Command/Query Bus)</h3>\n<p>애플리케이션에서 커맨드/쿼리 버스를 사용하는 경우에도 다이어그램은 거의 같으며, 유일한 차이는 컨트롤러가 애플리케이션 서비스나 쿼리 객체 대신 버스(Bus) 와 커맨드(Command) 또는 쿼리(Query) 객체에 의존한다는 점입니다. 컨트롤러는 커맨드나 쿼리를 생성해 이를 버스로 전달하고, 버스는 이를 처리할 적절한 핸들러(Handler)를 찾아 실행합니다.</p>\n<p>아래 다이어그램에서는 커맨드 핸들러가 다시 애플리케이션 서비스를 호출합니다. 하지만 대부분의 경우, 핸들러가 직접 유스케이스의 모든 로직을 포함합니다. 별도의 애플리케이션 서비스로 로직을 추출하는 경우는 같은 로직을 여러 핸들러에서 재사용할 필요가 있을 때뿐입니다.</p>\n<p>[2017-11-18 수정]\n처음에는 쿼리 결과를 전달하는 데 사용하는 DTO를 빠트렸었는데, 이를 <a href=\"%22https://www.reddit.com/user/MorphineAdministered%22\">MorphineAdministered</a>가 <a href=\"%22https://www.reddit.com/r/PHP/comments/7dcz8k/ddd_hexagonal_onion_clean_cqrs_how_i_put_it_all/dpy6va4/%22\">지적</a>해 주어 추가하였습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 794px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/515f4929ebb74bed2d14995aa9fb3a3a/7de01/4_3_UMLish_2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAACGklEQVR42oVS204UQRCdz/Ur/AyffPNFY9AHEw3BgLvBGCKwAyywuLuzzL3p6evcu3t61pohakQDJzWVqu45qUsfZzui7/uu62xn+t5CbC3Eg/WPwoEPyLW825wdeLPPppaQU99dnXxi4fn2/+hH2zr3me2UIKGkMWeEUsYovktTRhkXEhLOIMhlpWTZCFlAwEsFJ05RVlwWhGa+NyPpIsOptUPrOd1E66OmQNAZVFEFIdcT4X2vWCpupnKxj/yls7oNT+YL93q5DBKtDVSFUaGXzqiqFLCIZPNNZGtT8fD4A76atDmdv31+8vIZx7GDCfXjRBRVXtZKqSSJN+7rdLVvTQt8jlfIO8xZ2KjOjosFh7x5cHVU1o0Tx3EYBHB0619u/Ks4Cm/P3/gXO7omuhVo/YUlZ4VIeTTNk69Wl/CnMQa6E0I4URQjlBIaALltG4zS9dEL333Vlkhpm2NXxtMCn6Kb9+lix7RiIGvdGSOldMyIzpokXXubiyQJODpgxNWqHi6arGReJRMw3ZC+N8M6QALWDuTfb2e0ao2K3Bn++I4fTs0wJWilh55RNG8qCvN2I9QIxtgf8r1auOclu3toMmEYcyE45+HydHG8G3kXGSFZBo5gjMH/VfmXdB6iFmkWXOqK/nvlPBTeqOzBRpXDCajKXWN4mB8+qho1yHHEoO3tU2haFWUShkxprvSwMG1g3xr4T5MfwU/ldFFqYs5YeAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4_3_UMLish_2\"\n        title=\"\"\n        src=\"/static/515f4929ebb74bed2d14995aa9fb3a3a/7de01/4_3_UMLish_2.png\"\n        srcset=\"/static/515f4929ebb74bed2d14995aa9fb3a3a/772e8/4_3_UMLish_2.png 200w,\n/static/515f4929ebb74bed2d14995aa9fb3a3a/e17e5/4_3_UMLish_2.png 400w,\n/static/515f4929ebb74bed2d14995aa9fb3a3a/7de01/4_3_UMLish_2.png 794w\"\n        sizes=\"(max-width: 794px) 100vw, 794px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>여기서 눈여겨볼 점은 버스(Bus)가 커맨드, 쿼리, 핸들러와 직접적인 의존성이 없다는 것입니다. 좋은 결합도(Decoupling)를 유지하려면 이들은 서로의 존재를 몰라야 하며, 버스가 어떤 커맨드나 쿼리를 어떤 핸들러가 처리해야 하는지에 대한 설정은 별도의 설정(configuration)을 통해 결정됩니다.</p>\n<p>보시다시피, 두 경우 모두 애플리케이션 코어의 경계를 넘어가는 의존성 화살표는 항상 코어를 향해 안쪽으로 들어옵니다. 이는 포트 &#x26; 어댑터 아키텍처, 어니언 아키텍처, 클린 아키텍처의 가장 근본적인 원칙 중 하나입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/51f4c5ca45244b985b6ed75ff952db3b/0eb6d/4_3_Dependencies.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 13.999999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAIAAAAcOLh5AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvElEQVR42h3KTw+BYBwA4D6o72HdbI7YfAWbLi7+HMxwiMZS2ahJGknFRuhVeVNv9TOe80NpRxVHbwBA3sU6KTh0r5rJdHWmbzSHTo+7uubOV4UURw9buRsSSd4x9l+HRWCtqc1eDgK0s5/jpTLg5y1OLjXEatsu0wxdqNSLzM3UlpJQ6yijKcuyQ1617PPF1zlkiBT8fUgeEcgAHJRsDy7gV6ZvyGyS8Bx4XvgIViYKSR7nEMZZnJA0/+UvYQGbAL7tGZwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"4_3_Dependencies\"\n        title=\"\"\n        src=\"/static/51f4c5ca45244b985b6ed75ff952db3b/5a190/4_3_Dependencies.png\"\n        srcset=\"/static/51f4c5ca45244b985b6ed75ff952db3b/772e8/4_3_Dependencies.png 200w,\n/static/51f4c5ca45244b985b6ed75ff952db3b/e17e5/4_3_Dependencies.png 400w,\n/static/51f4c5ca45244b985b6ed75ff952db3b/5a190/4_3_Dependencies.png 800w,\n/static/51f4c5ca45244b985b6ed75ff952db3b/0eb6d/4_3_Dependencies.png 913w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 id=\"결론conclusion\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EB%A1%A0conclusion\" aria-label=\"결론conclusion permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결론(Conclusion)</h2>\n<p>항상 그렇듯, 목표는 결합도는 낮고 응집도는 높은(loose coupling, high cohesion) 코드베이스를 만드는 것입니다. 그래야 코드 변경이 쉽고 빠르며 안전하게 이루어질 수 있습니다.</p>\n<blockquote>\n<p>“계획 자체는 쓸모없지만, 계획하는 과정은 모든 것이다.”\n— 드와이트 아이젠하워(Eisenhower)</p>\n</blockquote>\n<p>이 인포그래픽은 개념 지도(concept map)입니다. 여기서 제시한 개념들을 이해하고 숙지하면 더욱 건강한 아키텍처와 애플리케이션을 설계하는 데 도움을 줄 것입니다.</p>\n<p>하지만, 다음 말을 꼭 기억해야 합니다.</p>\n<blockquote>\n<p>“지도가 곧 영토는 아니다.”\n— 알프레드 코르지브스키(Alfred Korzybski)</p>\n</blockquote>\n<p>즉, 위의 내용은 단지 가이드라인일 뿐입니다. 실제 애플리케이션이 우리가 적용하는 현실이며, 구체적인 유스케이스가 실제 아키텍처의 모습을 결정하게 됩니다.</p>\n<p>우리는 이러한 패턴을 모두 이해해야 하지만, 동시에 우리 애플리케이션이 정확히 무엇을 필요로 하는지, 결합도를 낮추고 응집도를 높이기 위해 어디까지 갈 것인지를 지속적으로 고민해야 합니다. 이 결정은 프로젝트의 기능적 요구사항뿐 아니라 개발 기간, 애플리케이션의 수명, 개발팀의 경험 등 수많은 요소에 따라 달라집니다.</p>\n<p>이것이 바로 제가 아키텍처를 이해하고 정리하는 방식입니다.</p>\n<p>이 개념들은 제 다음 글인 <a href=\"%22https://herbertograca.com/2018/07/07/more-than-concentric-layers/%22\">More than concentric layers</a>에서 더 확장하여 다뤘습니다.</p>\n<p>하지만 실제 코드에서 어떻게 이러한 아키텍처와 도메인을 명시적으로 드러낼 수 있을까요? 그것은 제 다음 포스트에서 다룰 주제입니다.</p>\n<p>마지막으로, 멋진 인포그래픽을 만드는 데 도움을 준 동료 <a href=\"%22https://www.linkedin.com/in/francescomastrogiacomo/%22\">Francesco Mastrogiacomo</a>에게 감사의 말을 전합니다.</p>","frontmatter":{"title":"DDD, Hexagonal, Onion, Clean, CQRS, ... 모두 종합한 방법","date":"2022-09-30","description":"[번역] DDD, Hexagonal, Onion, Clean, CQRS, ... How I put it all together","tags":["ddd","hexagonal","onion","cqrs","translation"]}}},"pageContext":{"slug":"/blog/2022/ddd-hexagonal-onion-clean-cqrs/","previous":{"fields":{"slug":"/blog/2022/domain-persistence/"},"frontmatter":{"title":"도메인 모델과 퍼시스턴스 모델 분리","tags":["domain","persistence","ddd","clean-architecture"]},"tableOfContents":""},"next":null}},"staticQueryHashes":["3526770880","3980716358"],"slicesMap":{}}